<!DOCTYPE html>

<html lang="ko">
<head>
<meta charset="utf-8"/>
  <!-- Ensure responsive behavior: without this, mobile browsers use a desktop viewport
       and CSS media queries (max-width/min-width) won't match as expected. -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
<title>OX í€´ì¦ˆ</title>
<style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Malgun Gothic', sans-serif;
      background-image: url('ìƒ‰.png');
      background-size: cover;
    }
    .quiz-box {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 80vh;
      text-align: center;
      position: relative;
      border: 8px solid #2196f3;
      background-color: white;
      border-radius: 20px;
      box-sizing: border-box;
      padding: 20px;
      max-width: 90%;
      margin: 5vh auto;
    }
    .question {
      max-width: 800px;
      width: 100%;
      word-break: keep-all;
      /* use margin/padding for spacing instead of translate to keep flow predictable */
      margin-top: 20px;
    }
    .answer-buttons {
      display: flex;
      justify-content: space-evenly;
      gap: 50px;
      width: 100%;
      padding: 0 10px;
      margin-top: 60px;
      margin-bottom: 60px;
      box-sizing: border-box;
    }
    .btn {
      width: 67.5vw;
      height: 67.5vw;
      max-width: 262.5px;
      max-height: 262.5px;
      font-size: 12vw;
      font-weight: bold;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }
    .btn.o, .btn.x {
      background-color: transparent;
      padding: 0;
      border-radius: 0;
      box-shadow: none;
    }
    .btn.o img, .btn.x img {
      width: 350px;
      height: 350px;
      object-fit: contain;
      max-width: 40vw;
    }
    .btn.next, .btn.stats, .btn.reset {
      font-size: 35px;
      padding: 4px 8px;
      background-color: #607d8b;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      height: 88px;
      line-height: 1.2;
      margin-top: 20px;
    }
    .judgement.correct {
      color: #2196f3;
      font-size: 68px;
      font-weight: bold;
    }
    .judgement.wrong {
      color: #ff9800;
      font-size: 68px;
      font-weight: bold;
    }
    #finalScreen img {
      width: 507px;
      margin-bottom: 20px;
    }
    .bottom-img {
      width: 60%;
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none; /* don't block buttons on desktop */
    }

.topright-logo {
  position: absolute;
  top: 20px;
  right: 20px;
  height: 72px;
}
/* Image wrapper: make the image a predictable reference for absolute labels */
.quiz-image-wrap {
  position: relative;
  width: 100%;
  max-width: 650px; /* default max; media queries may override */
  margin: 0 auto;
}
.quiz-image-wrap img { display:block; width:100%; height:auto; }

/* Center the label horizontally and vertically inside the image wrapper.
   Use translate(-50%, -50%) so the label stays centered regardless of image size.
   Font-size is responsive using clamp so it won't overflow the banner. */
#quizLabel {
  position: absolute;
  /* move up 15px to align with explanation label adjustments */
  top: calc(50% - 10px);
  /* shift label 50px left relative to previous center offset (was -20px -> now -70px) */
  left: calc(50% - 0px) !important;
  transform: translate(-50%, -50%);
  z-index: 2;
  pointer-events: none;
  font-family: 'Arial Black', 'Malgun Gothic', sans-serif;
  font-weight: 700;
  white-space: nowrap;
  font-size: clamp(28px, 4.5vw, 44px);
  color: #0a2c5d;
}

/* Explanation label used on the explanation screen */
.explanation-label {
    position: absolute;
    /* move up 15px relative to the centered position */
    top: calc(50% - 15px);
    /* shift explanation label 50px further left (was -20px -> now -70px) */
    left: calc(50% - 40px) !important;
    transform: translate(-50%, -50%);
  z-index: 2;
  pointer-events: none;
  font-family: 'Arial Black', 'Malgun Gothic', sans-serif;
  font-weight: 700;
  white-space: nowrap;
  font-size: clamp(28px, 4.5vw, 40px);
  color: #0a2c5d;
}
</style>
<style>
  /* Desktop-specific layout tweaks to avoid buttons being covered and
     to make better use of horizontal space on wider screens. */
  @media (min-width: 1024px) {
    .quiz-box {
      max-width: 880px;
      height: 80vh;
      padding: 20px 28px; /* tighten padding so content has more space */
      padding-top: 48px; /* allow room for header/logo */
      box-sizing: border-box;
      overflow: visible; /* allow controls to sit above decorative images */
    }
    .question { font-size: 30px; line-height:1.15; }
    /* Move the quiz label higher (closer to top of the background image) and reduce size so it doesn't overlap header */
  #quizLabel { font-size: 34px !important; }
  /* keep the wrapper centered; nudge only the image by 3px so the visible
     yellow banner shifts right while the centered label remains fixed */
  .quiz-image-wrap { transform: none; }
  .quiz-image-wrap img { transform: translateX(100px); }
    .answer-buttons { gap: 64px; }
    .btn {
      width: 160px;
      height: 160px;
      max-width: none;
      max-height: none;
      font-size: 36px;
      border-radius: 50%;
    }
    .btn.o img, .btn.x img { width: 160px; height: 160px; }
    .btn.next, .btn.stats, .btn.reset {
      font-size: 18px;
      height: 52px;
      padding: 8px 14px;
      border-radius: 8px;
    }
    .btn.next { z-index: 20; position: relative; }
    .judgement.correct, .judgement.wrong { font-size: 60px; }
  /* final screen image smaller so text below is visible */
  #finalScreen img { width: 300px !important; height: auto !important; }
    /* reduce decorative images on desktop so they don't dominate the layout */
    /* override some inline widths with !important to ensure effect */
  #questionImage { width: 320px !important; height: auto !important; }
  #intro img:not(.topright-logo) { width: 46% !important; max-width: 520px; }
  .bottom-img { width: 18%; bottom: 18px; }
    /* logo slightly smaller on desktop to free vertical space */
    .topright-logo { height: 40px; }
    /* slightly reduce prominent text sizes on desktop */
  .question { font-size: 28px !important; }
  .judgement.correct, .judgement.wrong { font-size: 44px !important; }
  #finalResult { font-size: 40px !important; }

  /* override inline-large quiz label and explanation text and images */
  #quizLabel { font-size: 34px !important; }
  /* explanation background image and label */
  #explanationBox > div > img { width: 320px !important; height: auto !important; }
  /* nudge the explanation label left 50px and up 15px on desktop
    (preserve the existing transform behavior while offsetting position) */
  #explanationBox > div > div { font-size: 32px !important; top: calc(48% - 15px) !important; left: calc(55% - 30px) !important; transform: translateX(-50%) translateY(0) !important; }
  /* ensure the explanation text block that follows the image fits */
  #explanationText { font-size: 30px !important; }
  /* shrink final screen paragraphs so they stay inside the bordered box */
  #finalScreen p { font-size: 26px !important; }
  }
</style>
<!-- Large-desktop (â‰ˆ1920Ã—1080) tuning -->
<style>
  @media (min-width: 1600px) {
  .quiz-box { max-width: 1000px; padding-top: 40px; }
  #questionImage { width: 460px !important; height: auto !important; }
  /* keep label centered via .quiz-image-wrap; just increase font-size for large screens */
  #quizLabel { font-size: 44px !important; line-height: 1 !important; }
  #explanationBox > div > img { width: 460px !important; height: auto !important; }
  .explanation-label { font-size: 40px !important; line-height: 1 !important; }
  /* keep the wrapper centered on large desktop as well; a small 3px image
    nudge is enough to move the visible yellow banner */
  .quiz-image-wrap { transform: none; }
  .quiz-image-wrap img { transform: translateX(100px); }
  #finalScreen img { width: 340px !important; height: auto !important; }
  #finalResult { font-size: 44px !important; }
  #finalScreen p { font-size: 28px !important; }
  .btn { width: 180px; height: 180px; font-size: 40px; }
  .btn.o img, .btn.x img { width: 180px; height: 180px; }
}
</style>
<!-- Mobile tweaks -->
<style>
  /* Mobile: keep viewport-based responsive behavior but make sizes conservative
     so images/buttons don't overflow and elements don't overlap. This preserves
     the desktop rules while ensuring the mobile presentation is tidy. */
  @media (max-width: 767px) {
    /* Make the main boxed container adapt to short/tall viewports */
    .quiz-box {
      max-width: 96%;
      margin: 3vh auto;
      height: auto !important;
      min-height: calc(100vh - 40px);
      padding: 16px !important;
      box-sizing: border-box;
    }

    /* Reduce large inline images used on the intro/final screens */
    #intro img:not(.topright-logo),
    #intro img:not(.topright-logo),
    .quiz-image-wrap img,
    #finalScreen img {
      width: 80% !important;
      max-width: 420px !important;
      height: auto !important;
    }

    /* smaller top-right logo on mobile */
    .topright-logo { height: 36px !important; top: 12px; right: 12px; }

    /* reduce bottom decorative image so it doesn't compete with controls */
    .bottom-img { width: 30% !important; bottom: 12px !important; }

    /* Make O/X controls reasonable size on small screens */
    .btn { width: auto !important; height: auto !important; box-shadow: none; }
    .btn.o, .btn.x { display: inline-flex; align-items: center; justify-content: center; width: 48% !important; max-width: 180px !important; height: auto !important; border-radius: 50%; }
    .btn.o img, .btn.x img { width: 48vw !important; max-width: 160px !important; height: auto !important; }

    .btn.next, .btn.stats, .btn.reset { height: 48px !important; font-size: 18px !important; padding: 8px 14px !important; border-radius: 8px !important; }

    .question { font-size: 24px !important; }
    .judgement.correct, .judgement.wrong { font-size: 36px !important; }
    #finalResult { font-size: 32px !important; }

    /* Explanation label: small, stable nudge; remove debug outline */
    .explanation-label {
      top: 50% !important;
      left: 50% !important;
      transform: translate(calc(-50% + 30px), calc(-50% + 5px)) !important;
      font-size: clamp(20px, 6.5vw, 32px) !important;
      outline: none !important;
      z-index: 3 !important;
    }

    /* Defensive: ensure intro fixed inline widths don't force horizontal scroll */
    #intro img[alt="ì¸íŠ¸ë¡œ í€´ì¦ˆ"],
    #intro img[alt="ê°€ë¡œí˜• ì´ë¯¸ì§€"] { width: 70% !important; max-width: 420px !important; }
  }
</style>
<!-- Force explanation text to be ~1/3 of previous size for readability -->
<style>
  #explanationText { font-size: calc(50px / 3) !important; line-height: 1.25 !important; }
</style>
</head>
<body>
<div class="quiz-box" id="intro">
  <img alt="ê¸°ê´€ ë¡œê³ " class="topright-logo" src="ì œëª© ì—†ìŒ.png"/>
  <img alt="ê°€ë¡œí˜• ì´ë¯¸ì§€" src="garohyeong.png" style="width: 500px; margin-bottom: 20px;"/>
  <img alt="ì¸íŠ¸ë¡œ í€´ì¦ˆ" src="í€´ì¦ˆ.png" style="width: 850px; margin-bottom: 20px; margin-top: -10px;"/>
  <button class="btn next" onclick="startQuiz()">ì‹œì‘</button>
  <!-- í†µê³„ ë²„íŠ¼: í‘œì§€ ìš°ì¸¡ í•˜ë‹¨ì— í‘œì‹œ -->
  <button class="btn stats" onclick="showStats()" style="position:absolute; right:16px; bottom:16px; width:auto; height:auto; padding:8px 12px; font-size:20px; border-radius:6px;">ğŸ“Š í†µê³„ ë³´ê¸°</button>
</div>

<div class="quiz-box" id="quiz" style="display:none">
  <img alt="ê¸°ê´€ ë¡œê³ " class="topright-logo" src="ì œëª© ì—†ìŒ.png"/>
  <div class="quiz-image-wrap">
    <img id="questionImage" src="11ë²ˆ.png" alt="ì§ˆë¬¸ ë°°ê²½ ì´ë¯¸ì§€" />
    <div id="quizLabel">#QUIZ 1</div>
  </div>
  <div class="question" id="question" style="font-size: 52px; font-weight: bold; margin-bottom: 10px; padding: 10px;"></div>
  <div class="answer-buttons">
    <button class="btn o" onclick="checkAnswer(true)"><img alt="O" src="o.png"/></button>
    <button class="btn x" onclick="checkAnswer(false)"><img alt="X" src="x.png"/></button>
  </div>
  <img class="bottom-img" src="garohyeong.png"/>
</div>

<div class="quiz-box" id="explanationBox" style="display:none; position: relative;">
  <div class="quiz-image-wrap">
    <img src="11ë²ˆ.png" alt="í•´ì„¤ ë°°ê²½ ì´ë¯¸ì§€" />
    <div class="explanation-label">ë¬¸ì œ í•´ì„¤</div>
  </div>
  <img alt="ê¸°ê´€ ë¡œê³ " class="topright-logo" src="ì œëª© ì—†ìŒ.png"/>
  <div id="judgement"></div>
  <div class="explanation" id="explanationText" style="font-weight: bold; margin-bottom: 10px; padding: 10px;"></div>
  <button class="btn next" onclick="nextQuestion()">ë‹¤ìŒ</button>
  <img class="bottom-img" src="garohyeong.png"/>
</div>

<div class="quiz-box" id="finalScreen" style="display:none">
  <img alt="ê¸°ê´€ ë¡œê³ " class="topright-logo" src="ì œëª© ì—†ìŒ.png"/>
  <img alt="ë§ˆë¬´ë¦¬ ì´ë¯¸ì§€" src="serohyeong.png"/>
  <div class="explanation" id="finalResult" style="font-size: 68px; font-weight: bold;"></div>
  <p style="font-size: 50px; font-weight: bold; color: #2196f3;">ê²½ìƒë¶ë„ ì´ë™í¸ì˜ì‹œì„¤ ê¸°ìˆ ì§€ì›ì„¼í„°ëŠ”</p>
  <p style="font-size: 50px; font-weight: bold; color: #2196f3;">êµí†µì•½ìì˜ ì´ë™ í¸ì˜ë¥¼ ìœ„í•œ ì „ë¬¸ ê¸°ìˆ ì„ ì§€ì›í•˜ëŠ” ê¸°ê´€ì…ë‹ˆë‹¤.</p>
  <button class="btn reset" onclick="location.reload()">ğŸ”„ ì²˜ìŒìœ¼ë¡œ</button>
  <!-- í†µê³„ ë²„íŠ¼ì€ í‘œì§€ì— ì´ë™ë¨ -->
</div>

<!-- Load runtime env synchronously from root (preferred) so module can read it immediately. -->
<script src="/env.js"></script>
<script>
  // Backward-compat alias and loaded flag
  try{
    if(typeof window !== 'undefined' && typeof window.__env !== 'undefined' && typeof window._env === 'undefined'){
      window._env = window.__env;
    }
    try{ window.__env_loaded = !!(window.__env); }catch(e){}
  }catch(e){/* ignore */}
</script>
<script type="module">
  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

  // Runtime í™˜ê²½ë³€ìˆ˜(ê¶Œì¥): public/env.js ì—ì„œ window.__env ê°ì²´ë¥¼ ì„¤ì •í•˜ì„¸ìš”.
  // ì˜ˆ: public/env.js
  // window.__env = { SUPABASE_URL: 'https://xyz.supabase.co', SUPABASE_ANON_KEY: 'anon-xxx' }
  // ì €ì¥ì†Œì—ëŠ” ì‹¤ì œ í‚¤ë¥¼ ì»¤ë°‹í•˜ì§€ ë§ˆì‹œê³ , ë°°í¬ ì„œë²„ì—ì„œë§Œ ì œê³µí•˜ì„¸ìš”.
  const SUPABASE_URL = (window.__env && window.__env.SUPABASE_URL) || null;
  const SUPABASE_ANON_KEY = (window.__env && window.__env.SUPABASE_ANON_KEY) || null;

  let supabase;
  if (SUPABASE_URL && SUPABASE_ANON_KEY) {
    supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  } else {
    console.warn('Supabase keys not found. Create public/env.js with window.__env = { SUPABASE_URL, SUPABASE_ANON_KEY }');
    // Minimal stub to avoid runtime errors when supabase isn't configured.
    // The real supabase client returns a chainable query builder for .select(...).eq(...).limit(...)
    // so provide a compatible stub that supports common chained calls used by this page.
    supabase = {
      from: function() {
        return {
          // insert is awaited directly in submitAnswer -> keep as async
          insert: async function() { return { error: 'supabase-not-configured' }; },
          // select returns a chainable builder: select(...).eq(...).limit(...)
          select: function() {
            const result = { data: [], error: 'supabase-not-configured' };
            const builder = {
              eq: function() { return builder; },
              limit: async function() { return result; },
              order: function() { return builder; },
              // allow then/await patterns if someone awaits select() directly
              then: function(resolve) { return Promise.resolve(result).then(resolve); }
            };
            return builder;
          }
        }
      }
    };
  }

  const questions = [
    { text: "ìœ ëª¨ì°¨ ì´ìš©ìë„ êµí†µì•½ìì— í¬í•¨ëœë‹¤", answer: true, explanation: "ì¥ì• ì¸, ë…¸ë ¹ì, ì„ì‚°ë¶€, ì˜ìœ ì•„ë¥¼ ë™ë°˜í•œ ì‚¬ëŒ, ì–´ë¦°ì´ ë“±ì´ êµí†µì•½ìì— í¬í•¨ëœë‹¤." },
    { text: "ë³´ë„ëŠ” ì´ë™í¸ì˜ì‹œì„¤ ì„¤ì¹˜ ëŒ€ìƒì´ë‹¤.", answer: true, explanation: "ë³´ë„, ì—¬ê°ì‹œì„¤, êµí†µìˆ˜ë‹¨ ë“±ì´ ì´ë™í¸ì˜ì‹œì„¤ ì„¤ì¹˜ëŒ€ìƒì´ë‹¤." },
    { text: "ê²½ìƒë¶ë„ êµí†µì•½ì ì´ë™í¸ì˜ì‹œì„¤ ê¸°ìˆ ì§€ì›ì„¼í„°ëŠ” ê´‘ì—­ì´ë™ì§€ì› ì„œë¹„ìŠ¤ë¥¼ ì‹¤ì‹œí•œë‹¤", answer: false, explanation: "ì‹¤íƒœì¡°ì‚¬, êµìœ¡ ë° í™ë³´, ì—°êµ¬ì¡°ì‚¬, ì¢…í•©ìƒë‹´ì„¼í„° ë“± ê¸°ìˆ ê´€ë ¨ì—…ë¬´ê°€ ì£¼ ì—…ë¬´ì´ë‹¤." },
    { text: "êµí†µì•½ìë„ ê²½ìƒë¶ë„ ì´ë™í¸ì˜ì‹œì„¤ ê¸°ìˆ ì§€ì›ì„¼í„°ë¥¼ ì´ìš©í•  ìˆ˜ ìˆë‹¤.", answer: true, explanation: "ê´€ê³µì„œ, ì‚¬ì—…ì, êµí†µì•½ì ëª¨ë‘ ì´ìš© ê°€ëŠ¥í•˜ë‹¤." },
    { text: "ëŒ€ì¤‘êµí†µ ì´ìš©ì´ë‚˜ ì´ë™ì— ë¶ˆí¸ì„ ëŠë‚€ì ì´ ìˆë‹¤.", answer: true, explanation: "ë¶ˆí¸í•˜ì‹  ì‚¬í•­ì— ëŒ€í•´ ê²½ìƒë¶ë„ ì´ë™í¸ì˜ì‹œì„¤ ê¸°ìˆ ì§€ì›ì„¼í„°ì— í™ˆí˜ì´ì§€ ë˜ëŠ” ìœ ì„ ì „í™”ë¡œ ë¬¸ì˜ ì£¼ì„¸ìš”.<br>1566-7710" }
  ];

  let current = 0;
  let score = 0;
  let stats = questions.map(() => ({ o: 0, x: 0 }));
  // persistent session id (optional) and per-attempt submission id
  let sessionId = localStorage.getItem('ox_session_id');
  if(!sessionId){ sessionId = crypto.randomUUID(); localStorage.setItem('ox_session_id', sessionId); }
  // submissionId is generated each time the quiz is started so each attempt
  // counts as a separate participant. It is kept in-memory (not persisted).
  let submissionId = null;

  // quiz id from querystring (QRì— quiz íŒŒë¼ë¯¸í„° í¬í•¨í•˜ì„¸ìš”)
  const params = new URLSearchParams(location.search);
  const quizId = params.get('quiz') || 'ox_default_quiz';

  async function submitAnswer(qIndex, ans){
    try{
      const payload = {
        quiz_id: quizId,
        question_index: qIndex,
        answer: ans,
        session_id: sessionId,
        submission_id: submissionId,
        user_agent: navigator.userAgent,
        meta: { via: 'qr', submission_id: submissionId }
      };
      // Try inserting with submission_id first. If the table does not have
      // that column (older schema), retry inserting without it so submissions
      // continue to work.
      let res = await supabase.from('quiz_responses').insert([payload]);
      if(res && res.error){
        console.warn('submit error with submission_id, retrying without submission_id', res.error);
  const payload2 = Object.assign({}, payload);
  // older schemas may not have a submission_id column; keep it in meta
  delete payload2.submission_id;
        const res2 = await supabase.from('quiz_responses').insert([payload2]);
        if(res2 && res2.error){
          console.error('submit error (retry without submission_id) failed', res2.error);
        }else{
          console.log('submit success (without submission_id)');
        }
      }else{
        console.log('submit success', res && res.data ? res.data : null);
      }
    }catch(e){ console.error(e); }
  }

  function startQuiz() {
    // create a new submission id for this quiz attempt so repeated attempts
    // from the same browser are treated as distinct participants.
    try{ submissionId = crypto.randomUUID(); }catch(e){ submissionId = 's_'+Date.now(); }
    document.getElementById("intro").style.display = "none";
    document.getElementById("quiz").style.display = "flex";
    loadQuestion();
  }

  function loadQuestion() {
    document.getElementById("quiz").style.display = "flex";
    document.getElementById("explanationBox").style.display = "none";
    document.getElementById("question").textContent = questions[current].text;

    const questionImage = document.getElementById("questionImage");
    questionImage.src = "11ë²ˆ.png";
    document.getElementById("quizLabel").textContent = `#QUIZ ${current + 1}`;
    questionImage.style.display = "block";
  }

  function checkAnswer(userAnswer) {
    // í´ë¼ì´ì–¸íŠ¸ì—ì„œ ë‹µ ì œì¶œ
    submitAnswer(current, userAnswer ? 'O' : 'X');

    const correct = questions[current].answer;
    if (userAnswer) stats[current].o++;
    else stats[current].x++;
    // Count a correct answer only when it matches the correct value.
    if (userAnswer === correct) score++;

    document.getElementById("quiz").style.display = "none";
    document.getElementById("explanationBox").style.display = "flex";

    const judge = document.getElementById("judgement");
    const exp = document.getElementById("explanationText");
    if (current !== 4) {
      judge.textContent = userAnswer === correct ? "ì •ë‹µì…ë‹ˆë‹¤!" : "ì˜¤ë‹µì…ë‹ˆë‹¤!";
      judge.className = userAnswer === correct ? "judgement correct" : "judgement wrong";
    } else {
      judge.textContent = "";
    }
    exp.innerHTML = questions[current].explanation;
  }

  function nextQuestion() {
    current++;
    if (current < questions.length) {
      loadQuestion();
    } else {
      showFinal();
    }
  }

  function showFinal() {
    document.getElementById("explanationBox").style.display = "none";
    document.getElementById("finalScreen").style.display = "flex";
    // Show both raw correct count and percent score (ì •ë‹µìˆ˜/ë¬¸í•­ìˆ˜ * 100)
    const percent = questions.length > 0 ? Math.round((score / questions.length) * 100) : 0;
    document.getElementById("finalResult").textContent = `ì´ ${questions.length}ë¬¸ì œ ì¤‘ ${score}ê°œ ë§ì¶”ì…¨ìŠµë‹ˆë‹¤! (${percent}ì )`;
  }

  function showStats() {
    // ê´€ë¦¬ì ì¸ì¦ í›„ ì„œë²„ì— ì €ì¥ëœ ì „ì²´ ì‘ë‹µì„ ì§‘ê³„í•´ì„œ ë³´ì—¬ì¤ë‹ˆë‹¤.
    adminAuthAndShow();
  }

  // --- Admin UI & Stats -------------------------------------------------
  // ê°„ë‹¨í•œ íŒ¨ìŠ¤ì›Œë“œ ê¸°ë°˜ ë³´í˜¸: ì‹¤ì œ ìš´ì˜ì—ì„œëŠ” ì„œë²„ ì¸¡ ì¸ì¦ ë˜ëŠ”
  // ì•ˆì „í•œ RLS ì •ì±…ì„ ì‚¬ìš©í•˜ì„¸ìš”. ê¸°ë³¸ íŒ¨ìŠ¤ì›Œë“œë¥¼ ë°°í¬ ì „ì— ë°”ê¾¸ì„¸ìš”.
  const ADMIN_PASSWORD = '1111';

  // If skipPrompt is true, skip the password prompt (used when caller already validated admin)
  async function adminAuthAndShow(skipPrompt = false){
    if(!skipPrompt){
      const pwd = prompt('ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”');
      if(!pwd) return;
      if(pwd !== ADMIN_PASSWORD){ alert('ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤'); return; }
    }
    // Supabase í´ë¼ì´ì–¸íŠ¸ê°€ ì¤€ë¹„ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    if(!supabase || typeof supabase.from !== 'function'){
      alert('Supabase ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ì— public/env.jsë¥¼ ë°°ì¹˜í•˜ê±°ë‚˜ ë°°í¬ í™˜ê²½ì— Supabase í‚¤ë¥¼ ì„¤ì •í•´ ì£¼ì„¸ìš”.');
      console.warn('supabase not configured or invalid client', supabase);
      return;
    }
    // ìš°ì„ : Supabase ì„œë²„ ì¸¡ RPC(get_quiz_statistics)ë¥¼ ì‚¬ìš©í•´ ì§‘ê³„ ìš”ì²­ (ëŒ€ëŸ‰ ë°ì´í„°ì— ì í•©)
    // ê´€ë¦¬ìëŠ” Supabase SQL Editorì— ì•„ë˜ í•¨ìˆ˜ë¥¼ ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤. (ì•„ë˜ ì•ˆë‚´ ì°¸ê³ )
    try{
      // RPC í˜¸ì¶œ: í•¨ìˆ˜ëª…ì´ get_quiz_statisticsì´ê³  íŒŒë¼ë¯¸í„° ì´ë¦„ì€ p_quiz_idì…ë‹ˆë‹¤.
      const { data, error } = await supabase.rpc('get_quiz_statistics', { p_quiz_id: quizId });
      if(error){
        console.warn('RPC get_quiz_statistics failed, falling back to client aggregation', error);
        throw error;
      }

      // data: array of rows per question with fields: question_index, count_o, count_x, total_responses, correct_rate, total_participants, avg_score
      const panel = document.getElementById('adminPanel');
      if(!panel){ console.error('adminPanel element not found'); alert('ê´€ë¦¬ì íŒ¨ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í˜ì´ì§€ êµ¬ì¡°ë¥¼ í™•ì¸í•˜ì„¸ìš”.'); return; }

      const contentEl = panel.querySelector('.content');
      if(!contentEl){ throw new Error('panel .content element missing'); }

      // We'll use the RPC data for per-question counts, but compute the overall average
      // from raw rows to ensure average = (sum of participant scores) / participant count.
      // First derive per-question totals from RPC rows if present.
      let totalParticipants = 0;
      let totalResponses = 0;
      if(Array.isArray(data) && data.length>0){
        totalParticipants = data[0].total_participants || 0;
        if(typeof data[0].total_responses !== 'undefined'){
          const sumPerQuestion = data.reduce((s,r)=> s + (Number(r.total_responses)||0), 0);
          totalResponses = Math.round(sumPerQuestion / Math.max(1, questions.length));
        }
      }

      // Fetch raw rows to compute per-row participant scores (treat each response-row as a participant)
      // This ensures average = participant-score-sum / participant-count.
      let avgScoreDisplay = '0.00';
      try{
      // Do not request submission_id column directly because older DB schemas
      // may not have it. Fetch meta (JSON) instead and read submission_id from
      // meta if present.
      const { data: rows, error: rowsErr } = await supabase.from('quiz_responses').select('answer,question_index,session_id,meta').eq('quiz_id', quizId).limit(100000);
        if(!rowsErr && Array.isArray(rows)){
          totalResponses = rows.length;
          // Group rows by session_id when available so a single participant's
          // multiple answers (one per question) count as one participant.
          const sessions = new Map();
          let totalCorrectSum = 0;
          // build per-question stats (counts and correct counts)
          const perQuestionCorrect = Array(questions.length).fill(0).map(()=>0);
          const perQuestionCounts = Array(questions.length).fill(0).map(()=>({ o:0, x:0, total:0 }));
          for(const [i, r] of rows.entries()){
            const qi = Number(r.question_index);
            const ansRaw = r.answer;
            const ans = String(ansRaw).toUpperCase();
            // tally O/X counts
            if(typeof qi === 'number' && qi >= 0 && qi < perQuestionCounts.length){
              if(ans === 'O' || ans === 'TRUE' || ans === 'T') perQuestionCounts[qi].o++;
              else perQuestionCounts[qi].x++;
              perQuestionCounts[qi].total++;
            }
            const correctBool = !!(questions[qi] && questions[qi].answer);
            const isCorrect = ((ans === 'O' || ans === 'TRUE' || ans === 'T') === correctBool) ? 1 : 0;
            if(isCorrect) totalCorrectSum++;
            if(typeof qi === 'number' && qi >= 0 && qi < perQuestionCorrect.length && isCorrect) perQuestionCorrect[qi]++;

            const sid = (r.meta && r.meta.submission_id) || r.submission_id || r.session_id || `row_${i}`;
            sessions.set(sid, (sessions.get(sid) || 0) + isCorrect);
          }
          const participantCount = sessions.size;
          // Compute average as the mean of per-participant percentages so it
          // matches the single-player percent shown on the final screen.
          let sumParticipantPercent = 0;
          for(const correctCount of sessions.values()){
            const pPercent = (questions.length > 0) ? (correctCount / questions.length) * 100 : 0;
            sumParticipantPercent += pPercent;
          }
          const avgPercent = (participantCount > 0) ? (sumParticipantPercent / participantCount) : 0;
          avgScoreDisplay = avgPercent.toFixed(2);

          // If we have the admin panel open already, prefer to display these
          // per-question counts computed from raw rows rather than RPC values.
          // We'll stash them on the panel element for the rendering logic below.
          try{
            const panel = document.getElementById('adminPanel');
            if(panel){
              panel._perQuestionCorrect = perQuestionCorrect;
              panel._perQuestionCounts = perQuestionCounts;
              panel._totalResponses = totalResponses;
              panel._participantCount = participantCount;
            }
          }catch(e){/* ignore */}
        }
      }catch(e){ console.warn('failed to fetch rows for avg calc', e); }
  // Choose displayParticipants: prefer computed participant count (from submission_id grouping)
  // If the per-attempt participant count was computed and stored on the panel, use it.
  const panelEl = document.getElementById('adminPanel');
  const computedParticipantCount = panelEl && (typeof panelEl._participantCount === 'number') ? panelEl._participantCount : null;
  const displayParticipants = (computedParticipantCount !== null) ? computedParticipantCount : (totalParticipants && totalParticipants > 0 ? totalParticipants : totalResponses);
      let html = `<div style="padding:12px; max-height:360px; overflow:auto; font-size:14px;">
        <div style="margin-bottom:8px;"><strong>ì°¸ì—¬ì¸ì›:</strong> ${displayParticipants}</div>
        <div style="margin-bottom:8px;"><strong>í‰ê·  ì ìˆ˜:</strong> ${avgScoreDisplay} ì </div>
        <div style="margin-bottom:6px; font-weight:bold;">ë¬¸í•­ë³„ ê²°ê³¼</div>`;

      // Ensure we render rows for each question index in order
      const rpcRows = Array.isArray(data) ? data.sort((a,b)=> (a.question_index||0)-(b.question_index||0)) : [];
      // check if we computed per-question correct counts and counts from raw rows earlier
      const panelPerQ = (function(){ try{ const p = document.getElementById('adminPanel'); return p && p._perQuestionCorrect ? p._perQuestionCorrect : null; }catch(e){return null;} })();
      const panelPerCounts = (function(){ try{ const p = document.getElementById('adminPanel'); return p && p._perQuestionCounts ? p._perQuestionCounts : null; }catch(e){return null;} })();
      for(let i=0;i<questions.length;i++){
        const row = rpcRows.find(r=>Number(r.question_index)===i) || null;
        let countO = 0, countX = 0, total = 0;
        // Prefer per-question counts computed from raw rows when available
        if(panelPerCounts && typeof panelPerCounts[i] !== 'undefined'){
          countO = Number(panelPerCounts[i].o||0);
          countX = Number(panelPerCounts[i].x||0);
          total = Number(panelPerCounts[i].total||0);
        }else{
          countO = row ? Number(row.count_o||0) : 0;
          countX = row ? Number(row.count_x||0) : 0;
          total = row ? Number(row.total_responses||0) : 0;
        }
        // Prefer per-question correct counts from raw rows when available, otherwise fall back to RPC's correct_rate
        let correctRate = 0;
        if(panelPerQ && typeof panelPerQ[i] !== 'undefined' && total > 0){
          correctRate = ((panelPerQ[i] / total) * 100);
          correctRate = Number(correctRate).toFixed(2);
        }else{
          correctRate = row ? Number(row.correct_rate||0) : 0;
        }
        html += `<div style="margin-bottom:6px;"><strong>Q${i+1}</strong>: O=${countO} &nbsp; X=${countX} &nbsp; (ì´ ${total}) &nbsp; <em>ì •ë‹µë¥ : ${correctRate}%</em></div>`;
      }
      html += `</div>`;

      contentEl.innerHTML = html;
      panel.style.display = 'block';
      panel.scrollIntoView({behavior:'smooth'});

    }catch(rpcErr){
      // RPCê°€ ì—†ê±°ë‚˜ ì‹¤íŒ¨í•œ ê²½ìš° ê¸°ì¡´ í´ë¼ì´ì–¸íŠ¸ ì§‘ê³„ ë°©ì‹(ëª¨ë“  í–‰ì„ ì½ì–´ ë“¤ì—¬ ì§‘ê³„)ìœ¼ë¡œ í´ë°±
      try{
        const { data, error } = await supabase.from('quiz_responses').select('*').eq('quiz_id', quizId).limit(100000);
        if(error){ console.error('stat fetch error', error); alert('í†µê³„ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: '+(error.message||JSON.stringify(error))); return; }
        const agg = {};
        // Build per-session scores. If a row lacks session_id, treat that row as its own participant
        const perSessionScore = {};
        for(const [i, r] of (data || []).entries()){
          const qi = Number(r.question_index);
          const ans = String(r.answer).toUpperCase();
          if(!agg[qi]) agg[qi] = { O:0, X:0, total:0, correctCount:0 };
          if(ans === 'O' || ans === 'TRUE' || ans === 'T') agg[qi].O++;
          else agg[qi].X++;
          agg[qi].total++;

          // Determine whether this response was correct by comparing to the
          // authoritative answer in the `questions` array.
          const correctAnswerIsO = !!(questions[qi] && questions[qi].answer);
          const isCorrect = ((ans === 'O' || ans === 'TRUE' || ans === 'T') === correctAnswerIsO) ? 1 : 0;
          agg[qi].correctCount = (agg[qi].correctCount || 0) + isCorrect;

          // Group by submission_id (from meta if necessary) then session_id so a
          // single participant's answers across multiple questions count as
          // one participant rather than being counted once per question.
          const sessionKey = (r.meta && r.meta.submission_id) || r.submission_id || r.session_id || `row_${i}`;
          perSessionScore[sessionKey] = (perSessionScore[sessionKey] || 0) + isCorrect;
        }

        const participantIds = Object.keys(perSessionScore);
        const totalParticipants = participantIds.length;
        // sum of correct answers across participants
        const totalCorrectSum = participantIds.length > 0 ? participantIds.reduce((acc, id) => acc + (perSessionScore[id]||0), 0) : 0;
        // Average percent = (total correct across participants) / (participants * questions.length) * 100
        const avgScorePercent = (totalParticipants > 0 && questions.length > 0) ? (totalCorrectSum / (totalParticipants * questions.length)) * 100 : 0;
        const avgScoreDisplay = avgScorePercent.toFixed(2);

        // total responses is simply the number of rows fetched
        const totalResponses = Array.isArray(data) ? data.length : 0;

        let html = `<div style="padding:12px; max-height:360px; overflow:auto; font-size:14px;">
          <div style="margin-bottom:8px;"><strong>ì°¸ì—¬ì¸ì›:</strong> ${totalParticipants}</div>
          <div style="margin-bottom:8px;"><strong>í‰ê·  ì ìˆ˜:</strong> ${avgScoreDisplay} ì </div>
          <div style="margin-bottom:6px; font-weight:bold;">ë¬¸í•­ë³„ ê²°ê³¼</div>`;
        for(let i=0;i<questions.length;i++){
          const a = agg[i] || {O:0,X:0,total:0,correctCount:0};
          // Use the counted correct responses if available. If not, fall back
          // to interpreting O/X relative to the known correct answer.
          const correctCount = (typeof a.correctCount !== 'undefined' && a.correctCount !== null)
            ? a.correctCount
            : (questions[i] && questions[i].answer ? a.O : a.X);
          const correctRate = a.total ? ((correctCount / a.total) * 100).toFixed(2) : '0.00';
          html += `<div style="margin-bottom:6px;"><strong>Q${i+1}</strong>: O=${a.O} &nbsp; X=${a.X} &nbsp; (ì´ ${a.total}) &nbsp; <em>ì •ë‹µë¥ : ${correctRate}%</em></div>`;
        }
        html += `</div>`;

        const panel = document.getElementById('adminPanel');
        if(!panel){ console.error('adminPanel element not found'); alert('ê´€ë¦¬ì íŒ¨ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í˜ì´ì§€ êµ¬ì¡°ë¥¼ í™•ì¸í•˜ì„¸ìš”.'); return; }
        const contentEl = panel.querySelector('.content');
        if(!contentEl){ throw new Error('panel .content element missing'); }
        contentEl.innerHTML = html;
        panel.style.display = 'block';
        panel.scrollIntoView({behavior:'smooth'});
      }catch(e){ console.error(e); alert('ì˜¤ë¥˜'); }
    }
  }

  async function resetStatistics(){
    const pwd = prompt('ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”');
    if(!pwd) return;
    if(pwd !== ADMIN_PASSWORD){ alert('ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤'); return; }
    if(!confirm('ì •ë§ ì´ í€´ì¦ˆì˜ ëª¨ë“  ì‘ë‹µì„ ì‚­ì œí•˜ê³  í†µê³„ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) return;

    // 1) ìš°ì„  RPC í˜¸ì¶œ ì‹œë„
    try{
      // show progress in admin panel if present
      try{
        const panel = document.getElementById('adminPanel');
        const contentEl = panel && panel.querySelector && panel.querySelector('.content');
        if(contentEl) contentEl.innerHTML = '<div style="padding:12px;">ì´ˆê¸°í™” ì¤‘...(RPC í˜¸ì¶œ)</div>';
      }catch(e){/* ignore */}
      const { data, error } = await supabase.rpc('reset_quiz_statistics', { p_quiz_id: quizId });
      if(error){
        console.error('RPC reset error', error, data);
        const panel = document.getElementById('adminPanel');
        const contentEl = panel && panel.querySelector && panel.querySelector('.content');
        if(contentEl) contentEl.innerHTML = '<div style="padding:12px; color:#a00;">RPC ì‹¤íŒ¨: '+(error.message||JSON.stringify(error))+'</div>';
        alert('RPCë¡œ ì´ˆê¸°í™”í•˜ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:\n'+(error.message||JSON.stringify(error))+'\ní´ë°±ìœ¼ë¡œ ì‚­ì œë¥¼ ì‹œë„í•©ë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
        throw error;
      }
      console.log('RPC reset success', data);
      // show success in panel
      try{ const panel = document.getElementById('adminPanel'); const contentEl = panel && panel.querySelector && panel.querySelector('.content'); if(contentEl) contentEl.innerHTML = '<div style="padding:12px; color:green;">í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (RPC)</div>'; }catch(e){}
      alert('í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (RPC)');
      // ì´ë¯¸ ì´ˆê¸°í™” ê¶Œí•œì„ í™•ì¸í–ˆìœ¼ë¯€ë¡œ íŒ¨ìŠ¤ì›Œë“œ ì¬ì…ë ¥ì„ ê±´ë„ˆë›°ê³  íŒ¨ë„ì„ ê°±ì‹ í•©ë‹ˆë‹¤.
      try{ adminAuthAndShow(true); }catch(e){ console.error('adminAuthAndShow after reset error', e); }
      return;
    }catch(e){
      console.warn('RPC reset failed, falling back to client-side delete', e);
    }

    // 2) RPCê°€ ì—†ìœ¼ë©´ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‚­ì œ ì‹œë„ (ì£¼ì˜: RLSì— ë”°ë¼ ì‹¤íŒ¨í•  ìˆ˜ ìˆìŒ)
    try{
      try{
        const panel = document.getElementById('adminPanel');
        const contentEl = panel && panel.querySelector && panel.querySelector('.content');
        if(contentEl) contentEl.innerHTML = '<div style="padding:12px;">ì´ˆê¸°í™” ì¤‘...(ì‚­ì œ í˜¸ì¶œ)</div>';
      }catch(e){}
      const { data, error } = await supabase.from('quiz_responses').delete().eq('quiz_id', quizId);
      if(error){
        console.error('delete error', error, data);
        const panel = document.getElementById('adminPanel');
        const contentEl = panel && panel.querySelector && panel.querySelector('.content');
        if(contentEl) contentEl.innerHTML = '<div style="padding:12px; color:#a00;">ì‚­ì œ ì‹¤íŒ¨: '+(error.message||JSON.stringify(error))+'</div>';
        alert('ì´ˆê¸°í™” ì‹¤íŒ¨: '+(error.message||JSON.stringify(error))+'\në¸Œë¼ìš°ì € ì½˜ì†”ì˜ ìì„¸í•œ ì •ë³´ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
        return;
      }
      console.log('delete success', data);
      const deletedCount = Array.isArray(data) ? data.length : (data && data.count) ? data.count : 'ì•Œ ìˆ˜ ì—†ìŒ';
      try{ const panel = document.getElementById('adminPanel'); const contentEl = panel && panel.querySelector && panel.querySelector('.content'); if(contentEl) contentEl.innerHTML = '<div style="padding:12px; color:green;">í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚­ì œ ë°©ì‹) ì‚­ì œëœ í•­ëª©: '+deletedCount+'</div>'; }catch(e){}
      alert('í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚­ì œ ë°©ì‹)');
      // íŒ¨ë„ì„ ì¬ë¡œë”©í•˜ë˜ íŒ¨ìŠ¤ì›Œë“œ í”„ë¡¬í”„íŠ¸ëŠ” ìƒëµ
      try{ adminAuthAndShow(true); }catch(e){ console.error('adminAuthAndShow after delete error', e); }
    }catch(e){ console.error('reset error', e); alert('ì´ˆê¸°í™” ë„ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì„œë²„ ì¸¡ì—ì„œ RPC(reset_quiz_statistics)ë¥¼ ë§Œë“œëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.'); }
  }

  // Expose handlers to global scope so inline onclick attributes (in HTML) can call them.
  // When using <script type="module">, top-level functions are module-scoped and
  // not added to window â€” that prevents onclick="startQuiz()" from working.
  window.startQuiz = startQuiz;
  window.checkAnswer = checkAnswer;
  window.nextQuestion = nextQuestion;
  window.showStats = showStats;
  // expose admin handlers used by inline onclick attributes
  window.resetStatistics = resetStatistics;
  window.adminAuthAndShow = adminAuthAndShow;
  // Expose supabase to window for debugging (will be undefined if not configured)
  try{ window.supabase = supabase; }catch(e){/* ignore */}

  // Ensure adminPanel .content exists (defensive) once DOM is ready
  document.addEventListener('DOMContentLoaded', ()=>{
    const panel = document.getElementById('adminPanel');
    if(panel){
      let content = panel.querySelector('.content');
      if(!content){
        content = document.createElement('div');
        content.className = 'content';
        content.style.padding = '8px 12px';
        content.style.fontSize = '13px';
        content.style.color = '#111';
        content.textContent = 'ë¡œë”© ì¤‘...';
        // insert before the footer buttons if present
        const footer = panel.querySelector('div[style*="border-top"]');
        panel.insertBefore(content, footer || null);
      }
    }
  });
</script>
<!-- ê´€ë¦¬ì í†µê³„ íŒ¨ë„ (ì´ˆê¸° ìƒíƒœëŠ” ìˆ¨ê¹€) -->
<div id="adminPanel" style="display:none; position:fixed; right:12px; bottom:12px; width:360px; max-width:90%; background:#fff; border:2px solid #2196f3; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.2); z-index:9999; font-family: sans-serif;">
  <div style="display:flex; align-items:center; justify-content:space-between; padding:8px 12px; border-bottom:1px solid #eee; background:#f7fbff;">
    <strong style="font-size:14px;">ê´€ë¦¬ì í†µê³„</strong>
    <button onclick="document.getElementById('adminPanel').style.display='none'" style="border:none; background:transparent; cursor:pointer; font-size:18px;">âœ•</button>
  </div>
  <div class="content" style="padding:8px 12px; font-size:13px; color:#111">ë¡œë”© ì¤‘...</div>
  <div style="padding:8px 12px; border-top:1px solid #eee; text-align:right;">
    <button onclick="resetStatistics()" style="margin-right:8px; padding:6px 10px; border-radius:6px; border:none; background:#e53935; color:#fff; cursor:pointer">ì´ˆê¸°í™”</button>
    <button onclick="document.getElementById('adminPanel').style.display='none'" style="padding:6px 10px; border-radius:6px; border:none; background:#607d8b; color:#fff; cursor:pointer">ë‹«ê¸°</button>
  </div>
</div>
</body>
</html>
