<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OX í€´ì¦ˆ (Tailwind)</title>
  <!-- Tailwind CDN for quick prototype (use build integration for production) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* reduce base font-size to ~75% of the default to make all text smaller */
    body { font-size: 75%; }
  /* set question and explanation text to 16pt as requested */
  #question, #explanationText { font-size: 16pt !important; }
    /* small helpers for mode classes applied by JS */
    body.mode-4-3 .quiz-box { aspect-ratio: 4 / 3; }
    body.mode-16-9 .quiz-box { aspect-ratio: 16 / 9; }
    /* image wrapper label adjustments (pixel fine-tuning can stay here) */
    .quiz-label { text-shadow: 0 1px 0 rgba(255,255,255,0.6); }
    /* site logo: keep the 'ì œëª© ì—†ìŒ' logo identical on every screen */
    .site-logo{ position: absolute; top: 1rem; right: 1rem; height: 28px; }
  /* remove visual shadows around buttons inside the quiz frame */
  .fixed-frame button { box-shadow: none !important; }
    /* fixed frame used on all quiz screens so the blue border doesn't resize with content
       - width/height are clamped for mobile and desktop
       - content inside will scroll if it's too large */
    .fixed-frame{
      box-sizing: border-box;
      width: clamp(320px, 86vw, 880px);
      height: clamp(560px, 78vh, 800px);
      overflow: auto;
    }
    /* center the final-screen main text block (vertically + horizontally) */
    .final-center{
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: calc(100% - 3rem);
      text-align: center;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }
    /* final screen button in normal flow under the centered block */
    .final-button{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-top: 0.5rem;
    }
    /* make the explanation 'ë‹¤ìŒ' button longer by increasing horizontal padding 1.8x
       we override Tailwind's px-4 with a calc-based padding for left/right so
       the button visually extends without scaling text size */
    .next-btn{
      padding-left: calc(1rem * 1.8) !important;
      padding-right: calc(1rem * 1.8) !important;
    }
  </style>
</head>
<body class="min-h-screen bg-cover bg-center" style="background-image:url('ìƒ‰.png')">
  <!-- Simple mobile mode detector to toggle .mode-4-3 or .mode-16-9 on body -->
  <script>
    (function(){
      function updateMode(){
        try{
          var w = window.innerWidth || document.documentElement.clientWidth;
          var h = window.innerHeight || document.documentElement.clientHeight;
          document.body.classList.remove('mode-4-3','mode-16-9');
          if(w <= 767){
            var ar = (h > 0) ? (w / h) : 0;
            var threshold = 0.65625;
            if(ar >= threshold) document.body.classList.add('mode-4-3');
            else document.body.classList.add('mode-16-9');
          }
        }catch(e){ console.warn(e); }
      }
      updateMode();
      window.addEventListener('resize', updateMode);
      window.addEventListener('orientationchange', updateMode);
    })();
  </script>

  <!-- Intro -->
  <main class="max-w-3xl mx-auto px-4 py-8">
  <section id="intro" class="quiz-box fixed-frame relative flex flex-col items-center justify-center text-center mx-auto border-8 border-blue-500 bg-white rounded-2xl p-6 max-w-full" >
  <img class="site-logo" src="ì œëª© ì—†ìŒ.png" alt="ê¸°ê´€ ë¡œê³ " />
  <!-- moved garohyeong to the bottom to match other pages -->
  <img class="bottom-img w-[32.5%] absolute bottom-2 left-1/2 -translate-x-1/2 pointer-events-none" src="garohyeong.png" alt="garo" />
  <!-- 'í€´ì¦ˆ' scaled by 250%: w-1/3 (â‰ˆ33.33%) *2.5 = â‰ˆ83.33% => w-5/6; max-w 260px *2.5 = 650px -->
  <img class="mb-4 w-5/6 max-w-[650px]" src="í€´ì¦ˆ.png" alt="ì¸íŠ¸ë¡œ í€´ì¦ˆ" />
  <button class="start-btn bg-indigo-600 text-white px-6 py-3 rounded-md text-lg font-bold" onclick="startQuiz()">ì‹œì‘</button>
      <button class="btn-stats absolute right-4 bottom-4 bg-gray-600 text-white px-3 py-1 rounded-md text-sm" onclick="showStats()">ğŸ“Š í†µê³„ ë³´ê¸°</button>
    </section>

    <!-- Quiz screen -->
  <section id="quiz" class="quiz-box fixed-frame relative hidden flex-col items-center justify-center text-center mx-auto border-8 border-blue-500 bg-white rounded-2xl p-4 max-w-full">
  <img class="site-logo" src="ì œëª© ì—†ìŒ.png" alt="ê¸°ê´€ ë¡œê³ " />
      <div class="relative w-full max-w-[650px] mx-auto quiz-image-wrap">
  <!-- '11ë²ˆ' scaled by 200%: w-1/3 (â‰ˆ33.33%) *2 = â‰ˆ66.66% => w-2/3; max-w 220px *2 = 440px -->
  <img id="questionImage" class="w-2/3 max-w-[440px] h-auto rounded mx-auto" src="11ë²ˆ.png" alt="ë¬¸ì œ ë°°ê²½" />
  <!-- 'quizLabel' scaled by 180%: text-2xl (~24px) *1.8 = ~43px -->
  <div id="quizLabel" class="quiz-label absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 text-[#0a2c5d] font-extrabold text-[32px]">#QUIZ 1</div>
      </div>
  <!-- 'question' font-size scaled by 200%: text-lg (~18px) *2 = 36px => text-4xl -->
  <div id="question" class="question font-bold text-4xl mt-4 px-4"></div>
      <div class="answer-buttons flex justify-evenly gap-6 w-full px-4 mt-8 mb-8">
  <button class="btn-o flex items-center justify-center w-[166px] h-[166px] bg-white rounded-full" onclick="checkAnswer(true)"><img src="o.png" alt="O" class="w-[125px] h-[125px] object-contain"/></button>
  <button class="btn-x flex items-center justify-center w-[166px] h-[166px] bg-white rounded-full" onclick="checkAnswer(false)"><img src="x.png" alt="X" class="w-[125px] h-[125px] object-contain"/></button>
      </div>
  <img class="bottom-img w-[32.5%] absolute bottom-2 left-1/2 -translate-x-1/2 pointer-events-none" src="garohyeong.png" alt="garo" />
    </section>

    <!-- Explanation -->
  <section id="explanationBox" class="quiz-box fixed-frame relative hidden flex-col items-center justify-center text-center mx-auto border-8 border-blue-500 bg-white rounded-2xl p-4 max-w-full">
      <div class="relative w-full max-w-[650px] mx-auto quiz-image-wrap">
  <!-- match the quiz image sizing for consistency -->
  <img src="11ë²ˆ.png" class="w-2/3 max-w-[440px] h-auto rounded mx-auto" alt="í•´ì„¤ ë°°ê²½" />
  <div class="explanation-label absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 font-extrabold text-[32px] text-[#0a2c5d]">ë¬¸ì œ í•´ì„¤</div>
      </div>
  <img class="site-logo" src="ì œëª© ì—†ìŒ.png" alt="ê¸°ê´€ ë¡œê³ " />
  <div id="judgement" class="mt-4 text-3xl font-bold"></div>
  <div id="explanationText" class="explanation font-bold mt-2 px-4 text-[32px]"></div>
      <button class="next-btn final-button bg-gray-600 text-white px-4 py-2 rounded-md" onclick="nextQuestion()">ë‹¤ìŒ</button>
  <img class="bottom-img w-[32.5%] absolute bottom-2 left-1/2 -translate-x-1/2 pointer-events-none" src="garohyeong.png" alt="garo" />
    </section>

    <!-- Final -->
  <section id="finalScreen" class="quiz-box fixed-frame relative hidden flex-col items-center justify-center text-center mx-auto border-8 border-blue-500 bg-white rounded-2xl p-6 max-w-full">
  <img class="site-logo" src="ì œëª© ì—†ìŒ.png" alt="ê¸°ê´€ ë¡œê³ " />
  <!-- final image moved to the bottom to match other screens -->
      <div class="final-center">
        <div id="finalResult" class="text-3xl font-extrabold"></div>
        <p class="text-xl font-bold text-blue-600">ê²½ìƒë¶ë„ ì´ë™í¸ì˜ì‹œì„¤ ê¸°ìˆ ì§€ì›ì„¼í„°ëŠ”</p>
        <p class="text-xl font-bold text-blue-600">êµí†µì•½ìì˜ ì´ë™ í¸ì˜ë¥¼ ìœ„í•œ ì „ë¬¸ ê¸°ìˆ ì„ ì§€ì›í•˜ëŠ” ê¸°ê´€ì…ë‹ˆë‹¤.</p>
        <button class="reset-btn final-button bg-gray-600 text-white px-4 py-2 rounded-md" onclick="location.reload()">ğŸ”„ ì²˜ìŒìœ¼ë¡œ</button>
      </div>
  <!-- serohyeong moved to bottom-center inside the blue frame -->
  <img src="serohyeong.png" class="bottom-img w-1/2 max-w-[352px] absolute bottom-2 left-1/2 -translate-x-1/2 pointer-events-none" alt="ë§ˆë¬´ë¦¬ ì´ë¯¸ì§€" />
    </section>

  <!-- Admin Panel (absolute so it can be moved inside the blue frame) -->
  <div id="adminPanel" class="hidden absolute right-3 bottom-3 w-80 bg-white border-2 border-blue-500 rounded shadow-lg z-50">
      <div class="flex items-center justify-between p-3 border-b">
        <strong class="text-sm">ê´€ë¦¬ì í†µê³„</strong>
        <button class="text-lg" onclick="document.getElementById('adminPanel').style.display='none'">âœ•</button>
      </div>
      <div class="content p-3 text-sm">ë¡œë”© ì¤‘...</div>
      <div class="p-3 border-t text-right">
        <button class="bg-red-600 text-white px-3 py-1 rounded mr-2" onclick="resetStatistics()">ì´ˆê¸°í™”</button>
        <button class="bg-gray-600 text-white px-3 py-1 rounded" onclick="document.getElementById('adminPanel').style.display='none'">ë‹«ê¸°</button>
      </div>
    </div>

  </main>

  <!-- Runtime env loader (optional) -->
  <script src="/env.js"></script>
  <script>
    try{ if(window.__env && !window._env) window._env = window.__env; }catch(e){}
  </script>

  <script>
    // Minimal supabase stub (no external import) to keep example runnable without keys.
    const SUPABASE_URL = (window.__env && window.__env.SUPABASE_URL) || null;
    const SUPABASE_ANON_KEY = (window.__env && window.__env.SUPABASE_ANON_KEY) || null;
    let supabase = null;
    if(!SUPABASE_URL || !SUPABASE_ANON_KEY){
      console.warn('Supabase keys not found. Using stub.');
      supabase = {
        from: () => ({
          insert: async ()=>({ error: 'supabase-not-configured' }),
          select: ()=>({ eq: ()=>({ limit: async ()=>({ data: [], error: 'supabase-not-configured' }) }) })
        })
      };
    } else {
      // If keys are present, attempt dynamic import of supabase client
      (async ()=>{
        try{
          const m = await import('https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm');
          supabase = m.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
          window.supabase = supabase;
        }catch(e){ console.warn('failed to load supabase client', e); }
      })();
    }

    const questions = [
      { text: "ìœ ëª¨ì°¨ ì´ìš©ìë„ êµí†µì•½ìì— í¬í•¨ëœë‹¤", answer: true, explanation: "ì¥ì• ì¸, ë…¸ë ¹ì, ì„ì‚°ë¶€, ì˜ìœ ì•„ë¥¼ ë™ë°˜í•œ ì‚¬ëŒ, ì–´ë¦°ì´ ë“±ì´ êµí†µì•½ìì— í¬í•¨ëœë‹¤." },
      { text: "ë³´ë„ëŠ” ì´ë™í¸ì˜ì‹œì„¤ ì„¤ì¹˜ ëŒ€ìƒì´ë‹¤.", answer: true, explanation: "ë³´ë„, ì—¬ê°ì‹œì„¤, êµí†µìˆ˜ë‹¨ ë“±ì´ ì´ë™í¸ì˜ì‹œì„¤ ì„¤ì¹˜ëŒ€ìƒì´ë‹¤." },
      { text: "ê²½ìƒë¶ë„ êµí†µì•½ì ì´ë™í¸ì˜ì‹œì„¤ ê¸°ìˆ ì§€ì›ì„¼í„°ëŠ” ê´‘ì—­ì´ë™ì§€ì› ì„œë¹„ìŠ¤ë¥¼ ì‹¤ì‹œí•œë‹¤", answer: false, explanation: "ì‹¤íƒœì¡°ì‚¬, êµìœ¡ ë° í™ë³´, ì—°êµ¬ì¡°ì‚¬, ì¢…í•©ìƒë‹´ì„¼í„° ë“± ê¸°ìˆ ê´€ë ¨ì—…ë¬´ê°€ ì£¼ ì—…ë¬´ì´ë‹¤." },
      { text: "êµí†µì•½ìë„ ê²½ìƒë¶ë„ ì´ë™í¸ì˜ì‹œì„¤ ê¸°ìˆ ì§€ì›ì„¼í„°ë¥¼ ì´ìš©í•  ìˆ˜ ìˆë‹¤.", answer: true, explanation: "ê´€ê³µì„œ, ì‚¬ì—…ì, êµí†µì•½ì ëª¨ë‘ ì´ìš© ê°€ëŠ¥í•˜ë‹¤." },
      { text: "ëŒ€ì¤‘êµí†µ ì´ìš©ì´ë‚˜ ì´ë™ì— ë¶ˆí¸ì„ ëŠë‚€ì ì´ ìˆë‹¤.", answer: true, explanation: "ë¶ˆí¸í•˜ì‹  ì‚¬í•­ì— ëŒ€í•´ ê²½ìƒë¶ë„ ì´ë™í¸ì˜ì‹œì„¤ ê¸°ìˆ ì§€ì›ì„¼í„°ì— í™ˆí˜ì´ì§€ ë˜ëŠ” ìœ ì„ ì „í™”ë¡œ ë¬¸ì˜ ì£¼ì„¸ìš”.<br>1566-7710" }
    ];

    let current = 0; let score = 0; let submissionId = null;
    let sessionId = localStorage.getItem('ox_session_id');
    if(!sessionId){ sessionId = crypto.randomUUID ? crypto.randomUUID() : 's_'+Date.now(); localStorage.setItem('ox_session_id', sessionId); }

    async function submitAnswer(qIndex, ans){
      try{
        const payload = { quiz_id: 'ox_default_quiz', question_index: qIndex, answer: ans, session_id: sessionId, submission_id: submissionId, user_agent: navigator.userAgent, meta: { via:'tailwind' } };
        if(!supabase || !supabase.from){ console.log('stub submit', payload); return; }
        let res = await supabase.from('quiz_responses').insert([payload]);
        if(res && res.error) console.warn('submit error', res.error);
      }catch(e){ console.error(e); }
    }

    function startQuiz(){
      try{ submissionId = crypto.randomUUID(); }catch(e){ submissionId = 's_'+Date.now(); }
      // Lock the visual frame to the intro size so foldables (e.g. Galaxy Fold)
      // don't cause the blue border to resize when switching screens.
      try{ lockFrameToIntro(); }catch(e){ console.warn('lockFrameToIntro failed', e); }
      document.getElementById('intro').classList.add('hidden');
      document.getElementById('quiz').classList.remove('hidden');
      loadQuestion();
    }

    // Measure the intro box and set explicit width/height on all .fixed-frame
    // elements so the frame stays constant after the intro is hidden.
    function lockFrameToIntro(){
      const intro = document.getElementById('intro');
      if(!intro) return;
      // ensure intro is visible when measuring
      const prevDisplay = intro.style.display;
      intro.style.display = '';
      const rect = intro.getBoundingClientRect();
      // restore previous display (not strictly necessary here)
      intro.style.display = prevDisplay;
      const w = Math.max(200, Math.round(rect.width));
      const h = Math.max(200, Math.round(rect.height));
      document.querySelectorAll('.fixed-frame').forEach(el=>{
        el.style.width = w + 'px';
        el.style.height = h + 'px';
        el.style.overflow = 'auto';
      });
      // remember locked state
      document.body.setAttribute('data-frame-locked','1');
    }

    // Optional: remove inline locks to return to responsive clamps (not used by default)
    function unlockFrame(){
      document.querySelectorAll('.fixed-frame').forEach(el=>{
        el.style.width = '';
        el.style.height = '';
        el.style.overflow = '';
      });
      document.body.removeAttribute('data-frame-locked');
    }
    function loadQuestion(){
      document.getElementById('quiz').classList.remove('hidden');
      document.getElementById('explanationBox').classList.add('hidden');
      const qEl = document.getElementById('question');
      qEl.textContent = questions[current].text;
      document.getElementById('quizLabel').textContent = `#QUIZ ${current+1}`;
      document.getElementById('questionImage').src = '11ë²ˆ.png';
    }
    function checkAnswer(userAnswer){
      submitAnswer(current, userAnswer ? 'O' : 'X');
      const correct = questions[current].answer;
      if(userAnswer === correct) score++;
      // tally omitted (client-side) - show explanation
      document.getElementById('quiz').classList.add('hidden');
      document.getElementById('explanationBox').classList.remove('hidden');
      const judge = document.getElementById('judgement');
      judge.textContent = userAnswer === correct ? 'ì •ë‹µì…ë‹ˆë‹¤!' : 'ì˜¤ë‹µì…ë‹ˆë‹¤!';
      judge.className = userAnswer === correct ? 'mt-4 text-3xl font-bold text-blue-600' : 'mt-4 text-3xl font-bold text-orange-500';
      document.getElementById('explanationText').innerHTML = questions[current].explanation;
    }
    function nextQuestion(){ current++; if(current < questions.length) loadQuestion(); else showFinal(); }
    function showFinal(){ document.getElementById('explanationBox').classList.add('hidden'); document.getElementById('finalScreen').classList.remove('hidden'); const percent = questions.length>0? Math.round((score/questions.length)*100):0; document.getElementById('finalResult').textContent = `ì´ ${questions.length}ë¬¸ì œ ì¤‘ ${score}ê°œ ë§ì¶”ì…¨ìŠµë‹ˆë‹¤! (${percent}ì )`; }

    // admin basic functions (stubbed similarly to main file)
    const ADMIN_PASSWORD = '1111';
    async function adminAuthAndShow(skipPrompt = false){
    if(!skipPrompt){
      const pwd = prompt('ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”');
      if(!pwd) return;
      if(pwd !== ADMIN_PASSWORD){ alert('ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤'); return; }
    }
    // Supabase í´ë¼ì´ì–¸íŠ¸ê°€ ì¤€ë¹„ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    if(!supabase || typeof supabase.from !== 'function'){
      alert('Supabase ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ì— public/env.jsë¥¼ ë°°ì¹˜í•˜ê±°ë‚˜ ë°°í¬ í™˜ê²½ì— Supabase í‚¤ë¥¼ ì„¤ì •í•´ ì£¼ì„¸ìš”.');
      console.warn('supabase not configured or invalid client', supabase);
      return;
    }
    // ìš°ì„ : Supabase ì„œë²„ ì¸¡ RPC(get_quiz_statistics)ë¥¼ ì‚¬ìš©í•´ ì§‘ê³„ ìš”ì²­ (ëŒ€ëŸ‰ ë°ì´í„°ì— ì í•©)
    // ê´€ë¦¬ìëŠ” Supabase SQL Editorì— ì•„ë˜ í•¨ìˆ˜ë¥¼ ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤. (ì•„ë˜ ì•ˆë‚´ ì°¸ê³ )
    try{
      // RPC í˜¸ì¶œ: í•¨ìˆ˜ëª…ì´ get_quiz_statisticsì´ê³  íŒŒë¼ë¯¸í„° ì´ë¦„ì€ p_quiz_idì…ë‹ˆë‹¤.
      const { data, error } = await supabase.rpc('get_quiz_statistics', { p_quiz_id: quizId });
      if(error){
        console.warn('RPC get_quiz_statistics failed, falling back to client aggregation', error);
        throw error;
      }

      // data: array of rows per question with fields: question_index, count_o, count_x, total_responses, correct_rate, total_participants, avg_score
      const panel = document.getElementById('adminPanel');
      if(!panel){ console.error('adminPanel element not found'); alert('ê´€ë¦¬ì íŒ¨ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í˜ì´ì§€ êµ¬ì¡°ë¥¼ í™•ì¸í•˜ì„¸ìš”.'); return; }

      const contentEl = panel.querySelector('.content');
      if(!contentEl){ throw new Error('panel .content element missing'); }

      // We'll use the RPC data for per-question counts, but compute the overall average
      // from raw rows to ensure average = (sum of participant scores) / participant count.
      // First derive per-question totals from RPC rows if present.
      let totalParticipants = 0;
      let totalResponses = 0;
      if(Array.isArray(data) && data.length>0){
        totalParticipants = data[0].total_participants || 0;
        if(typeof data[0].total_responses !== 'undefined'){
          const sumPerQuestion = data.reduce((s,r)=> s + (Number(r.total_responses)||0), 0);
          totalResponses = Math.round(sumPerQuestion / Math.max(1, questions.length));
        }
      }

      // Fetch raw rows to compute per-row participant scores (treat each response-row as a participant)
      // This ensures average = participant-score-sum / participant-count.
      let avgScoreDisplay = '0.00';
      try{
      // Do not request submission_id column directly because older DB schemas
      // may not have it. Fetch meta (JSON) instead and read submission_id from
      // meta if present.
      const { data: rows, error: rowsErr } = await supabase.from('quiz_responses').select('answer,question_index,session_id,meta').eq('quiz_id', quizId).limit(100000);
        if(!rowsErr && Array.isArray(rows)){
          totalResponses = rows.length;
          // Group rows by session_id when available so a single participant's
          // multiple answers (one per question) count as one participant.
          const sessions = new Map();
          let totalCorrectSum = 0;
          // build per-question stats (counts and correct counts)
          const perQuestionCorrect = Array(questions.length).fill(0).map(()=>0);
          const perQuestionCounts = Array(questions.length).fill(0).map(()=>({ o:0, x:0, total:0 }));
          for(const [i, r] of rows.entries()){
            const qi = Number(r.question_index);
            const ansRaw = r.answer;
            const ans = String(ansRaw).toUpperCase();
            // tally O/X counts
            if(typeof qi === 'number' && qi >= 0 && qi < perQuestionCounts.length){
              if(ans === 'O' || ans === 'TRUE' || ans === 'T') perQuestionCounts[qi].o++;
              else perQuestionCounts[qi].x++;
              perQuestionCounts[qi].total++;
            }
            const correctBool = !!(questions[qi] && questions[qi].answer);
            const isCorrect = ((ans === 'O' || ans === 'TRUE' || ans === 'T') === correctBool) ? 1 : 0;
            if(isCorrect) totalCorrectSum++;
            if(typeof qi === 'number' && qi >= 0 && qi < perQuestionCorrect.length && isCorrect) perQuestionCorrect[qi]++;

            const sid = (r.meta && r.meta.submission_id) || r.submission_id || r.session_id || `row_${i}`;
            sessions.set(sid, (sessions.get(sid) || 0) + isCorrect);
          }
          const participantCount = sessions.size;
          // Compute average as the mean of per-participant percentages so it
          // matches the single-player percent shown on the final screen.
          let sumParticipantPercent = 0;
          for(const correctCount of sessions.values()){
            const pPercent = (questions.length > 0) ? (correctCount / questions.length) * 100 : 0;
            sumParticipantPercent += pPercent;
          }
          const avgPercent = (participantCount > 0) ? (sumParticipantPercent / participantCount) : 0;
          avgScoreDisplay = avgPercent.toFixed(2);

          // If we have the admin panel open already, prefer to display these
          // per-question counts computed from raw rows rather than RPC values.
          // We'll stash them on the panel element for the rendering logic below.
          try{
            const panel = document.getElementById('adminPanel');
            if(panel){
              panel._perQuestionCorrect = perQuestionCorrect;
              panel._perQuestionCounts = perQuestionCounts;
              panel._totalResponses = totalResponses;
              panel._participantCount = participantCount;
            }
          }catch(e){/* ignore */}
        }
      }catch(e){ console.warn('failed to fetch rows for avg calc', e); }
  // Choose displayParticipants: prefer computed participant count (from submission_id grouping)
  // If the per-attempt participant count was computed and stored on the panel, use it.
  const panelEl = document.getElementById('adminPanel');
  const computedParticipantCount = panelEl && (typeof panelEl._participantCount === 'number') ? panelEl._participantCount : null;
  const displayParticipants = (computedParticipantCount !== null) ? computedParticipantCount : (totalParticipants && totalParticipants > 0 ? totalParticipants : totalResponses);
      let html = `<div style="padding:12px; max-height:360px; overflow:auto; font-size:14px;">
        <div style="margin-bottom:8px;"><strong>ì°¸ì—¬ì¸ì›:</strong> ${displayParticipants}</div>
        <div style="margin-bottom:8px;"><strong>í‰ê·  ì ìˆ˜:</strong> ${avgScoreDisplay} ì </div>
        <div style="margin-bottom:6px; font-weight:bold;">ë¬¸í•­ë³„ ê²°ê³¼</div>`;

      // Ensure we render rows for each question index in order
      const rpcRows = Array.isArray(data) ? data.sort((a,b)=> (a.question_index||0)-(b.question_index||0)) : [];
      // check if we computed per-question correct counts and counts from raw rows earlier
      const panelPerQ = (function(){ try{ const p = document.getElementById('adminPanel'); return p && p._perQuestionCorrect ? p._perQuestionCorrect : null; }catch(e){return null;} })();
      const panelPerCounts = (function(){ try{ const p = document.getElementById('adminPanel'); return p && p._perQuestionCounts ? p._perQuestionCounts : null; }catch(e){return null;} })();
      for(let i=0;i<questions.length;i++){
        const row = rpcRows.find(r=>Number(r.question_index)===i) || null;
        let countO = 0, countX = 0, total = 0;
        // Prefer per-question counts computed from raw rows when available
        if(panelPerCounts && typeof panelPerCounts[i] !== 'undefined'){
          countO = Number(panelPerCounts[i].o||0);
          countX = Number(panelPerCounts[i].x||0);
          total = Number(panelPerCounts[i].total||0);
        }else{
          countO = row ? Number(row.count_o||0) : 0;
          countX = row ? Number(row.count_x||0) : 0;
          total = row ? Number(row.total_responses||0) : 0;
        }
        // Prefer per-question correct counts from raw rows when available, otherwise fall back to RPC's correct_rate
        let correctRate = 0;
        if(panelPerQ && typeof panelPerQ[i] !== 'undefined' && total > 0){
          correctRate = ((panelPerQ[i] / total) * 100);
          correctRate = Number(correctRate).toFixed(2);
        }else{
          correctRate = row ? Number(row.correct_rate||0) : 0;
        }
        html += `<div style="margin-bottom:6px;"><strong>Q${i+1}</strong>: O=${countO} &nbsp; X=${countX} &nbsp; (ì´ ${total}) &nbsp; <em>ì •ë‹µë¥ : ${correctRate}%</em></div>`;
      }
      html += `</div>`;

      contentEl.innerHTML = html;
      panel.style.display = 'block';
      panel.scrollIntoView({behavior:'smooth'});

    }catch(rpcErr){
      // RPCê°€ ì—†ê±°ë‚˜ ì‹¤íŒ¨í•œ ê²½ìš° ê¸°ì¡´ í´ë¼ì´ì–¸íŠ¸ ì§‘ê³„ ë°©ì‹(ëª¨ë“  í–‰ì„ ì½ì–´ ë“¤ì—¬ ì§‘ê³„)ìœ¼ë¡œ í´ë°±
      try{
        const { data, error } = await supabase.from('quiz_responses').select('*').eq('quiz_id', quizId).limit(100000);
        if(error){ console.error('stat fetch error', error); alert('í†µê³„ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: '+(error.message||JSON.stringify(error))); return; }
        const agg = {};
        // Build per-session scores. If a row lacks session_id, treat that row as its own participant
        const perSessionScore = {};
        for(const [i, r] of (data || []).entries()){
          const qi = Number(r.question_index);
          const ans = String(r.answer).toUpperCase();
          if(!agg[qi]) agg[qi] = { O:0, X:0, total:0, correctCount:0 };
          if(ans === 'O' || ans === 'TRUE' || ans === 'T') agg[qi].O++;
          else agg[qi].X++;
          agg[qi].total++;

          // Determine whether this response was correct by comparing to the
          // authoritative answer in the `questions` array.
          const correctAnswerIsO = !!(questions[qi] && questions[qi].answer);
          const isCorrect = ((ans === 'O' || ans === 'TRUE' || ans === 'T') === correctAnswerIsO) ? 1 : 0;
          agg[qi].correctCount = (agg[qi].correctCount || 0) + isCorrect;

          // Group by submission_id (from meta if necessary) then session_id so a
          // single participant's answers across multiple questions count as
          // one participant rather than being counted once per question.
          const sessionKey = (r.meta && r.meta.submission_id) || r.submission_id || r.session_id || `row_${i}`;
          perSessionScore[sessionKey] = (perSessionScore[sessionKey] || 0) + isCorrect;
        }

        const participantIds = Object.keys(perSessionScore);
        const totalParticipants = participantIds.length;
        // sum of correct answers across participants
        const totalCorrectSum = participantIds.length > 0 ? participantIds.reduce((acc, id) => acc + (perSessionScore[id]||0), 0) : 0;
        // Average percent = (total correct across participants) / (participants * questions.length) * 100
        const avgScorePercent = (totalParticipants > 0 && questions.length > 0) ? (totalCorrectSum / (totalParticipants * questions.length)) * 100 : 0;
        const avgScoreDisplay = avgScorePercent.toFixed(2);

        // total responses is simply the number of rows fetched
        const totalResponses = Array.isArray(data) ? data.length : 0;

        let html = `<div style="padding:12px; max-height:360px; overflow:auto; font-size:14px;">
          <div style="margin-bottom:8px;"><strong>ì°¸ì—¬ì¸ì›:</strong> ${totalParticipants}</div>
          <div style="margin-bottom:8px;"><strong>í‰ê·  ì ìˆ˜:</strong> ${avgScoreDisplay} ì </div>
          <div style="margin-bottom:6px; font-weight:bold;">ë¬¸í•­ë³„ ê²°ê³¼</div>`;
        for(let i=0;i<questions.length;i++){
          const a = agg[i] || {O:0,X:0,total:0,correctCount:0};
          // Use the counted correct responses if available. If not, fall back
          // to interpreting O/X relative to the known correct answer.
          const correctCount = (typeof a.correctCount !== 'undefined' && a.correctCount !== null)
            ? a.correctCount
            : (questions[i] && questions[i].answer ? a.O : a.X);
          const correctRate = a.total ? ((correctCount / a.total) * 100).toFixed(2) : '0.00';
          html += `<div style="margin-bottom:6px;"><strong>Q${i+1}</strong>: O=${a.O} &nbsp; X=${a.X} &nbsp; (ì´ ${a.total}) &nbsp; <em>ì •ë‹µë¥ : ${correctRate}%</em></div>`;
        }
        html += `</div>`;

        const panel = document.getElementById('adminPanel');
        if(!panel){ console.error('adminPanel element not found'); alert('ê´€ë¦¬ì íŒ¨ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í˜ì´ì§€ êµ¬ì¡°ë¥¼ í™•ì¸í•˜ì„¸ìš”.'); return; }
        const contentEl = panel.querySelector('.content');
        if(!contentEl){ throw new Error('panel .content element missing'); }
        contentEl.innerHTML = html;
        panel.style.display = 'block';
        panel.scrollIntoView({behavior:'smooth'});
      }catch(e){
        console.error('adminAuthAndShow error', e);
        try{
          const panel = document.getElementById('adminPanel');
          const contentEl = panel && panel.querySelector && panel.querySelector('.content');
          if(contentEl) contentEl.innerHTML = '<div style="color:#a00;">ì˜¤ë¥˜: '+(e && e.message ? e.message : String(e))+'</div>' + '<pre style="white-space:pre-wrap; font-size:12px;">'+(e && e.stack ? e.stack : '')+'</pre>';
        }catch(err){ console.error('failed to render admin error', err); }
        alert('í†µê³„ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê°œë°œì ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
      }
    }
  }
    async function showStats(){ adminAuthAndShow(); }
    async function resetStatistics(){
    const pwd = prompt('ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”');
    if(!pwd) return;
    if(pwd !== ADMIN_PASSWORD){ alert('ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤'); return; }
    if(!confirm('ì •ë§ ì´ í€´ì¦ˆì˜ ëª¨ë“  ì‘ë‹µì„ ì‚­ì œí•˜ê³  í†µê³„ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) return;

    // 1) ìš°ì„  RPC í˜¸ì¶œ ì‹œë„
    try{
      // show progress in admin panel if present
      try{
        const panel = document.getElementById('adminPanel');
        const contentEl = panel && panel.querySelector && panel.querySelector('.content');
        if(contentEl) contentEl.innerHTML = '<div style="padding:12px;">ì´ˆê¸°í™” ì¤‘...(RPC í˜¸ì¶œ)</div>';
      }catch(e){/* ignore */}
      const { data, error } = await supabase.rpc('reset_quiz_statistics', { p_quiz_id: quizId });
      if(error){
        console.error('RPC reset error', error, data);
        const panel = document.getElementById('adminPanel');
        const contentEl = panel && panel.querySelector && panel.querySelector('.content');
        if(contentEl) contentEl.innerHTML = '<div style="padding:12px; color:#a00;">RPC ì‹¤íŒ¨: '+(error.message||JSON.stringify(error))+'</div>';
        alert('RPCë¡œ ì´ˆê¸°í™”í•˜ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:\n'+(error.message||JSON.stringify(error))+'\ní´ë°±ìœ¼ë¡œ ì‚­ì œë¥¼ ì‹œë„í•©ë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
        throw error;
      }
      console.log('RPC reset success', data);
      // show success in panel
      try{ const panel = document.getElementById('adminPanel'); const contentEl = panel && panel.querySelector && panel.querySelector('.content'); if(contentEl) contentEl.innerHTML = '<div style="padding:12px; color:green;">í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (RPC)</div>'; }catch(e){}
      alert('í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (RPC)');
      // ì´ë¯¸ ì´ˆê¸°í™” ê¶Œí•œì„ í™•ì¸í–ˆìœ¼ë¯€ë¡œ íŒ¨ìŠ¤ì›Œë“œ ì¬ì…ë ¥ì„ ê±´ë„ˆë›°ê³  íŒ¨ë„ì„ ê°±ì‹ í•©ë‹ˆë‹¤.
      try{ adminAuthAndShow(true); }catch(e){ console.error('adminAuthAndShow after reset error', e); }
      return;
    }catch(e){
      console.warn('RPC reset failed, falling back to client-side delete', e);
    }

    // 2) RPCê°€ ì—†ìœ¼ë©´ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‚­ì œ ì‹œë„ (ì£¼ì˜: RLSì— ë”°ë¼ ì‹¤íŒ¨í•  ìˆ˜ ìˆìŒ)
    try{
      try{
        const panel = document.getElementById('adminPanel');
        const contentEl = panel && panel.querySelector && panel.querySelector('.content');
        if(contentEl) contentEl.innerHTML = '<div style="padding:12px;">ì´ˆê¸°í™” ì¤‘...(ì‚­ì œ í˜¸ì¶œ)</div>';
      }catch(e){}
      const { data, error } = await supabase.from('quiz_responses').delete().eq('quiz_id', quizId);
      if(error){
        console.error('delete error', error, data);
        const panel = document.getElementById('adminPanel');
        const contentEl = panel && panel.querySelector && panel.querySelector('.content');
        if(contentEl) contentEl.innerHTML = '<div style="padding:12px; color:#a00;">ì‚­ì œ ì‹¤íŒ¨: '+(error.message||JSON.stringify(error))+'</div>';
        alert('ì´ˆê¸°í™” ì‹¤íŒ¨: '+(error.message||JSON.stringify(error))+'\në¸Œë¼ìš°ì € ì½˜ì†”ì˜ ìì„¸í•œ ì •ë³´ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
        return;
      }
      console.log('delete success', data);
      const deletedCount = Array.isArray(data) ? data.length : (data && data.count) ? data.count : 'ì•Œ ìˆ˜ ì—†ìŒ';
      try{ const panel = document.getElementById('adminPanel'); const contentEl = panel && panel.querySelector && panel.querySelector('.content'); if(contentEl) contentEl.innerHTML = '<div style="padding:12px; color:green;">í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚­ì œ ë°©ì‹) ì‚­ì œëœ í•­ëª©: '+deletedCount+'</div>'; }catch(e){}
      alert('í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚­ì œ ë°©ì‹)');
      // íŒ¨ë„ì„ ì¬ë¡œë”©í•˜ë˜ íŒ¨ìŠ¤ì›Œë“œ í”„ë¡¬í”„íŠ¸ëŠ” ìƒëµ
      try{ adminAuthAndShow(true); }catch(e){ console.error('adminAuthAndShow after delete error', e); }
    }catch(e){ console.error('reset error', e); alert('ì´ˆê¸°í™” ë„ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì„œë²„ ì¸¡ì—ì„œ RPC(reset_quiz_statistics)ë¥¼ ë§Œë“œëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.'); }
    }

    // expose for inline onclick
    window.startQuiz = startQuiz; window.checkAnswer = checkAnswer; window.nextQuestion = nextQuestion; window.showStats = showStats; window.resetStatistics = resetStatistics; window.adminAuthAndShow = adminAuthAndShow;
  </script>
</body>
</html>
