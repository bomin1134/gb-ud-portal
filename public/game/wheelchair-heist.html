<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ìú†Ï≤¥Ïñ¥ ÎèÑÎëë ÎåÄÌÉàÏ£º - Wheelchair Heist</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            color: white;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        canvas {
            display: block;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        /* UI Ìå®ÎÑê */
        #game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #00ff88;
            min-width: 300px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }
        
        #game-ui h2 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 24px;
            text-shadow: 0 0 10px #00ff88;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            font-weight: bold;
            color: #fff;
        }
        
        .thief-stat {
            color: #ff4444;
        }
        
        .cop-stat {
            color: #4444ff;
        }
        
        /* ÏÑ∏ÎåÄ Ï†ïÎ≥¥ */
        #generation-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #ff88ff;
            min-width: 280px;
            box-shadow: 0 0 30px rgba(255, 136, 255, 0.5);
        }
        
        #generation-info h3 {
            color: #ff88ff;
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        .generation-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .win-rate {
            font-size: 28px;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .strategy {
            color: #ffdd44;
            font-style: italic;
            margin-top: 5px;
        }
        
        /* Í±∞Î¶¨ Í≤åÏù¥ÏßÄ */
        #distance-gauge {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 25px;
            border: 3px solid #ffff00;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
        }
        
        #distance-bar {
            width: 400px;
            height: 30px;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        
        #distance-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.3s;
        }
        
        #distance-text {
            text-align: center;
            margin-top: 8px;
            font-size: 20px;
            font-weight: bold;
        }
        
        /* Ïª®Ìä∏Î°§ Ìå®ÎÑê */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        
        .control-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ff88;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background: #00ff88;
            color: black;
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ff88;
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        /* Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ */
        #event-log {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 250px;
            max-height: 400px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #888;
        }
        
        .event-item {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            font-size: 14px;
            animation: slideIn 0.3s;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .event-thief {
            background: rgba(255, 68, 68, 0.3);
            border-left: 4px solid #ff4444;
        }
        
        .event-cop {
            background: rgba(68, 68, 255, 0.3);
            border-left: 4px solid #4444ff;
        }
        
        .event-system {
            background: rgba(255, 255, 255, 0.2);
            border-left: 4px solid #888;
        }
        
        /* Î™®Î∞îÏùº Î©îÎâ¥ */
        #mobile-menu {
            position: absolute;
            top: 20px;
            left: 20px;
            display: none;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            padding: 10px;
            z-index: 1000;
        }
        
        #menu-toggle {
            display: none;
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            z-index: 999;
        }
        
        @media (max-width: 768px) {
            #game-ui, #generation-info, #event-log {
                display: none;
            }
            
            #menu-toggle {
                display: block;
            }
            
            #mobile-menu.active {
                display: block;
            }
            
            #distance-gauge {
                bottom: 120px;
            }
            
            #distance-bar {
                width: 250px;
            }
            
            #controls {
                flex-direction: column;
                bottom: 10px;
            }
            
            .control-btn {
                padding: 12px 24px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- Î©îÎâ¥ ÌÜ†Í∏Ä (Î™®Î∞îÏùº) -->
    <button id="menu-toggle">‚ò∞  Î©îÎâ¥</button>
    
    <!-- Î™®Î∞îÏùº Î©îÎâ¥ -->
    <div id="mobile-menu">
        <h3>üìä Í≤åÏûÑ Ï†ïÎ≥¥</h3>
        <div id="mobile-stats"></div>
    </div>
    
    <!-- Í≤åÏûÑ UI -->
    <div id="game-ui">
        <h2>üö® Ìú†Ï≤¥Ïñ¥ ÎèÑÎëë ÎåÄÌÉàÏ£º</h2>
        <div class="stat-row">
            <span class="stat-label">ÌòÑÏû¨ ÎùºÏö¥Îìú</span>
            <span class="stat-value" id="round-number">1</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Í≤ΩÍ≥º ÏãúÍ∞Ñ</span>
            <span class="stat-value" id="elapsed-time">0.0s</span>
        </div>
        <div class="stat-row">
            <span class="stat-label thief-stat">ü¶Ω ÎèÑÎëë Ïàò</span>
            <span class="stat-value thief-stat" id="thief-count">3</span>
        </div>
        <div class="stat-row">
            <span class="stat-label cop-stat">üöî Í≤ΩÏ∞∞ Ïàò</span>
            <span class="stat-value cop-stat" id="cop-count">3</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Îßµ ÎÇúÏù¥ÎèÑ</span>
            <span class="stat-value" id="map-difficulty">Í∏∞Î≥∏</span>
        </div>
    </div>
    
    <!-- ÏÑ∏ÎåÄ Ï†ïÎ≥¥ -->
    <div id="generation-info">
        <div class="generation-box">
            <h3>ü¶Ω ÎèÑÎëë AI</h3>
            <div class="stat-row">
                <span>ÏÑ∏ÎåÄ</span>
                <span id="thief-generation">1ÏÑ∏ÎåÄ</span>
            </div>
            <div class="win-rate thief-stat" id="thief-winrate">0%</div>
            <div class="strategy" id="thief-strategy">ÌïôÏäµ Ï§ë...</div>
        </div>
        
        <div class="generation-box">
            <h3>üöî Í≤ΩÏ∞∞ AI</h3>
            <div class="stat-row">
                <span>ÏÑ∏ÎåÄ</span>
                <span id="cop-generation">1ÏÑ∏ÎåÄ</span>
            </div>
            <div class="win-rate cop-stat" id="cop-winrate">0%</div>
            <div class="strategy" id="cop-strategy">ÌïôÏäµ Ï§ë...</div>
        </div>
        
        <!-- AI Î™®Îìú ÌÜ†Í∏Ä -->
        <div class="generation-box" style="background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd700; margin-top: 15px;">
            <h3 style="color: #ffd700;">ü§ñ AI Î™®Îìú</h3>
            <button class="control-btn" id="btn-ai-mode" style="width: 100%; margin-top: 10px; padding: 10px; font-size: 14px;">
                ü¶Ω ÎèÑÎëëÎßå AI
            </button>
            <div style="margin-top: 10px; font-size: 12px; color: #aaa; text-align: center;" id="ai-mode-desc">
                Í≤ΩÏ∞∞: ÌîåÎ†àÏù¥Ïñ¥ Ï°∞Ïûë
            </div>
        </div>
    </div>
    
    <!-- Í±∞Î¶¨ Í≤åÏù¥ÏßÄ -->
    <div id="distance-gauge">
        <div id="distance-bar">
            <div id="distance-fill" style="width: 50%"></div>
        </div>
        <div id="distance-text">Í±∞Î¶¨: -- m</div>
    </div>
    
    <!-- Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ -->
    <div id="event-log">
        <h4 style="margin-bottom: 10px; color: #ffdd44;">üìã Ïù¥Î≤§Ìä∏</h4>
        <div id="log-items"></div>
    </div>
    
    <!-- Ïª®Ìä∏Î°§ -->
    <div id="controls">
        <button class="control-btn" id="btn-start">‚ñ∂Ô∏è ÏãúÏûë</button>
        <button class="control-btn" id="btn-pause">‚è∏Ô∏è ÏùºÏãúÏ†ïÏßÄ</button>
        <button class="control-btn" id="btn-reset">üîÑ Î¶¨ÏÖã</button>
        <button class="control-btn" id="btn-speed">‚ö° ÏÜçÎèÑ: 1x</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    
    <script>
        // Í≤åÏûÑ Ï¥àÍ∏∞ÌôîÎ•º ÎûòÌïëÌïòÎäî Ìï®Ïàò
        function initGame() {
            // Three.jsÏôÄ Cannon.js Î°úÎìú ÌôïÏù∏
            if (typeof THREE === 'undefined' || typeof CANNON === 'undefined') {
                console.error('Three.js ÎòêÎäî Cannon.jsÍ∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
                setTimeout(initGame, 100);
                return;
            }

            console.log('üéÆ Ìú†Ï≤¥Ïñ¥ ÎèÑÎëë ÎåÄÌÉàÏ£º Ï¥àÍ∏∞Ìôî Ï§ë...');

            // ===== Í≤åÏûÑ ÏÉÅÌÉú =====
            const gameState = {
                playing: false,
                paused: false,
                speed: 1,
                round: 1,
                startTime: 0,
                elapsedTime: 0,
                
                aiMode: 'thief-only', // 'thief-only', 'both', 'cop-only'
                
                thiefGeneration: 1,
                copGeneration: 1,
                
                thiefWins: 0,
                copWins: 0,
                totalRounds: 0,
                
                thiefStrategies: [
                    'ÏßÅÏÑ† ÎèÑÏ£º',
                    'Í≤ΩÏÇ¨Î°ú Ï∞æÍ∏∞',
                    'ÌÑ± ÌöåÌîº',
                    'Í±∞Î¶¨ Ïú†ÏßÄ',
                    'ÏßÄÍ∑∏Ïû¨Í∑∏',
                    'ÎØ∏ÎÅº ÏûëÏ†Ñ',
                    'ÌòëÎ†• ÌÉàÏ∂ú'
                ],
                copStrategies: [
                    'ÏßÅÏÑ† Ï∂îÍ≤©',
                    'ÏòàÏ∏° Ïù¥Îèô',
                    'Ïä§ÌÉúÎØ∏ÎÇò Í¥ÄÎ¶¨',
                    'Ìè¨ÏúÑ ÏûëÏ†Ñ',
                    'Ìå®ÌÑ¥ Î∂ÑÏÑù',
                    'Ìï®Ï†ï ÏÑ§Ïπò',
                    'ÌåÄÏõåÌÅ¨'
                ]
            };

            // ===== Three.js ÏÑ§Ï†ï =====
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

            const camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 40, 50);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ===== Ï°∞Î™Ö =====
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // ===== Cannon.js Î¨ºÎ¶¨ ÏóîÏßÑ =====
            const world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Ïû¨Ïßà ÏÑ§Ï†ï
            const groundMaterial = new CANNON.Material('ground');
            const entityMaterial = new CANNON.Material('entity');
            
            const contactMaterial = new CANNON.ContactMaterial(
                groundMaterial,
                entityMaterial,
                {
                    friction: 0.4,
                    restitution: 0.1
                }
            );
            world.addContactMaterial(contactMaterial);

            // ===== Î∞îÎã• =====
            const groundGeometry = new THREE.PlaneGeometry(100, 200);
            const groundMaterialThree = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterialThree);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ 
                mass: 0,
                material: groundMaterial
            });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            // ===== Í≥µÏú† Ïû¨Ïßà (ÌÖçÏä§Ï≤ò Ïú†Îãõ Ï†àÏïΩ) =====
            const sharedMaterials = {
                thief: new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.7 }),
                cop: new THREE.MeshStandardMaterial({ color: 0x4444ff, roughness: 0.7 }),
                obstacle: new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8 }),
                ramp: new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 }),
                goal: new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00, 
                    emissive: 0x00ff00, 
                    emissiveIntensity: 0.3 
                })
            };

            // ===== Ìú†Ï≤¥Ïñ¥ ÎèÑÎëë ÌÅ¥ÎûòÏä§ =====
            class WheelchairThief {
                constructor(x, z, ai) {
                    this.ai = ai;
                    this.escaped = false;
                    this.caught = false;
                    this.speed = 0;
                    this.maxSpeed = 8;  // ÏµúÍ≥†ÏÜçÎèÑ ÎÜíÏùå
                    this.acceleration = 0.3;
                    this.turnSpeed = 0.08;
                    this.targetAngle = 0;
                    
                    // Ìú†Ï≤¥Ïñ¥ Í∑∏Î£π
                    this.mesh = new THREE.Group();
                    this.mesh.position.set(x, 0.3, z);
                    scene.add(this.mesh);
                    
                    // Ìú†Ï≤¥Ïñ¥ Ï¢åÏÑù
                    const seatGeom = new THREE.BoxGeometry(0.7, 0.1, 0.7);
                    const seat = new THREE.Mesh(seatGeom, sharedMaterials.thief);
                    seat.position.y = 0;
                    seat.castShadow = true;
                    this.mesh.add(seat);
                    
                    // Ìú†Ï≤¥Ïñ¥ Îì±Î∞õÏù¥
                    const backGeom = new THREE.BoxGeometry(0.7, 0.6, 0.1);
                    const back = new THREE.Mesh(backGeom, sharedMaterials.thief);
                    back.position.set(0, 0.3, -0.3);
                    back.castShadow = true;
                    this.mesh.add(back);
                    
                    // ÏÇ¨Îûå Î™∏ÌÜµ
                    const bodyGeom = new THREE.BoxGeometry(0.4, 0.5, 0.3);
                    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff8844 });
                    const body = new THREE.Mesh(bodyGeom, bodyMat);
                    body.position.set(0, 0.45, -0.1);
                    body.castShadow = true;
                    this.mesh.add(body);
                    
                    // ÏÇ¨Îûå Î®∏Î¶¨
                    const headGeom = new THREE.SphereGeometry(0.2, 8, 8);
                    const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
                    const head = new THREE.Mesh(headGeom, headMat);
                    head.position.set(0, 0.85, -0.1);
                    head.castShadow = true;
                    this.mesh.add(head);
                    
                    // Ìåî
                    const armGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 6);
                    const leftArm = new THREE.Mesh(armGeom, bodyMat);
                    leftArm.position.set(-0.25, 0.4, -0.1);
                    leftArm.rotation.z = Math.PI / 6;
                    this.mesh.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeom, bodyMat);
                    rightArm.position.set(0.25, 0.4, -0.1);
                    rightArm.rotation.z = -Math.PI / 6;
                    this.mesh.add(rightArm);
                    
                    // Î¨ºÎ¶¨ Î∞îÎîî
                    const shape = new CANNON.Box(new CANNON.Vec3(0.4, 0.3, 0.6));
                    this.body = new CANNON.Body({
                        mass: 15,
                        material: entityMaterial,
                        linearDamping: 0.3,
                        angularDamping: 0.8
                    });
                    this.body.addShape(shape);
                    this.body.position.set(x, 0.3, z);
                    this.body.fixedRotation = true;
                    this.body.updateMassProperties();
                    world.addBody(this.body);
                    
                    // Î∞îÌÄ¥ ÌëúÏãú
                    const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
                    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
                    
                    this.wheels = [];
                    const wheelPositions = [
                        [-0.3, -0.2, 0.4],
                        [0.3, -0.2, 0.4],
                        [-0.3, -0.2, -0.4],
                        [0.3, -0.2, -0.4]
                    ];
                    
                    wheelPositions.forEach(pos => {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(pos[0], pos[1], pos[2]);
                        this.mesh.add(wheel);
                        this.wheels.push(wheel);
                    });
                }
                
                update(obstacles, goal, nearestCop) {
                    if (this.escaped || this.caught) return;
                    
                    // AI ÏùòÏÇ¨Í≤∞Ï†ï
                    const decision = this.ai.decide(this.body.position, obstacles, goal, nearestCop);
                    this.targetAngle = decision.targetAngle;
                    const desiredSpeed = decision.speed;
                    
                    // ÏÜçÎèÑ Ï°∞Ï†à
                    if (this.speed < desiredSpeed) {
                        this.speed += this.acceleration;
                    } else if (this.speed > desiredSpeed) {
                        this.speed -= this.acceleration * 0.5;
                    }
                    this.speed = Math.max(0, Math.min(this.maxSpeed, this.speed));
                    
                    // ÌöåÏ†Ñ
                    const currentAngle = Math.atan2(
                        this.body.velocity.z,
                        this.body.velocity.x
                    );
                    
                    let angleDiff = this.targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    const turnAmount = angleDiff * this.turnSpeed;
                    
                    // Ïù¥Îèô
                    const moveX = Math.cos(currentAngle + turnAmount) * this.speed;
                    const moveZ = Math.sin(currentAngle + turnAmount) * this.speed;
                    
                    this.body.velocity.x = moveX;
                    this.body.velocity.z = moveZ;
                    this.body.velocity.y = Math.max(this.body.velocity.y, -10);
                    
                    // Î©îÏãú ÏóÖÎç∞Ïù¥Ìä∏
                    this.mesh.position.copy(this.body.position);
                    this.mesh.quaternion.copy(this.body.quaternion);
                    
                    // Î∞îÌÄ¥ ÌöåÏ†Ñ
                    this.wheels.forEach(wheel => {
                        wheel.rotation.x += this.speed * 0.1;
                    });
                    
                    // ÌÉàÏ∂ú Ï≤¥ÌÅ¨
                    if (this.body.position.z < goal.z + 2) {
                        this.escaped = true;
                        addLog('ü¶Ω ÎèÑÎëëÏù¥ ÌÉàÏ∂úÌñàÏäµÎãàÎã§!', 'thief');
                    }
                }
                
                remove() {
                    scene.remove(this.mesh);
                    world.removeBody(this.body);
                }
            }

            // ===== Í≤ΩÏ∞∞ ÌÅ¥ÎûòÏä§ =====
            class Cop {
                constructor(x, z, ai) {
                    this.ai = ai;
                    this.speed = 0;
                    this.maxSpeed = 5;  // ÌèâÍ∑†ÏÜçÎèÑ ÎÜíÏùå
                    this.acceleration = 0.2;
                    this.turnSpeed = 0.12;
                    this.targetAngle = 0;
                    
                    // Í≤ΩÏ∞∞ Í∑∏Î£π
                    this.mesh = new THREE.Group();
                    this.mesh.position.set(x, 0, z);
                    scene.add(this.mesh);
                    
                    // Îã§Î¶¨
                    const legGeom = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 8);
                    const legMat = new THREE.MeshStandardMaterial({ color: 0x000088 });
                    const leftLeg = new THREE.Mesh(legGeom, legMat);
                    leftLeg.position.set(-0.15, 0.4, 0);
                    leftLeg.castShadow = true;
                    this.mesh.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeom, legMat);
                    rightLeg.position.set(0.15, 0.4, 0);
                    rightLeg.castShadow = true;
                    this.mesh.add(rightLeg);
                    this.leftLeg = leftLeg;
                    this.rightLeg = rightLeg;
                    
                    // Î™∏ÌÜµ
                    const bodyGeom = new THREE.BoxGeometry(0.5, 0.7, 0.3);
                    const body = new THREE.Mesh(bodyGeom, sharedMaterials.cop);
                    body.position.set(0, 1.15, 0);
                    body.castShadow = true;
                    this.mesh.add(body);
                    
                    // Î®∏Î¶¨
                    const headGeom = new THREE.SphereGeometry(0.25, 8, 8);
                    const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
                    const head = new THREE.Mesh(headGeom, headMat);
                    head.position.set(0, 1.65, 0);
                    head.castShadow = true;
                    this.mesh.add(head);
                    
                    // Í≤ΩÏ∞∞ Î™®Ïûê
                    const hatGeom = new THREE.CylinderGeometry(0.27, 0.27, 0.15, 8);
                    const hatMat = new THREE.MeshStandardMaterial({ color: 0x000088 });
                    const hat = new THREE.Mesh(hatGeom, hatMat);
                    hat.position.set(0, 1.85, 0);
                    this.mesh.add(hat);
                    
                    // Ìåî
                    const armGeom = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 6);
                    const armMat = new THREE.MeshStandardMaterial({ color: 0x4444ff });
                    const leftArm = new THREE.Mesh(armGeom, armMat);
                    leftArm.position.set(-0.35, 1.1, 0);
                    leftArm.rotation.z = Math.PI / 8;
                    this.mesh.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeom, armMat);
                    rightArm.position.set(0.35, 1.1, 0);
                    rightArm.rotation.z = -Math.PI / 8;
                    this.mesh.add(rightArm);
                    this.leftArm = leftArm;
                    this.rightArm = rightArm;
                    
                    this.walkCycle = 0;
                    
                    // Î¨ºÎ¶¨ Î∞îÎîî
                    const shape = new CANNON.Cylinder(0.3, 0.3, 1.8, 8);
                    this.body = new CANNON.Body({
                        mass: 10,
                        material: entityMaterial,
                        linearDamping: 0.4,
                        angularDamping: 0.9
                    });
                    this.body.addShape(shape);
                    this.body.position.set(x, 0.9, z);
                    this.body.fixedRotation = true;
                    world.addBody(this.body);
                }
                
                update(thieves, obstacles) {
                    // Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÎèÑÎëë Ï∞æÍ∏∞
                    let nearestThief = null;
                    let minDist = Infinity;
                    
                    thieves.forEach(thief => {
                        if (thief.escaped || thief.caught) return;
                        
                        const dx = thief.body.position.x - this.body.position.x;
                        const dz = thief.body.position.z - this.body.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            nearestThief = thief;
                        }
                    });
                    
                    if (!nearestThief) {
                        this.speed = 0;
                        return;
                    }
                    
                    // AI ÏùòÏÇ¨Í≤∞Ï†ï
                    const decision = this.ai.decide(
                        this.body.position,
                        nearestThief.body.position,
                        obstacles,
                        minDist
                    );
                    
                    this.targetAngle = decision.targetAngle;
                    const desiredSpeed = decision.speed;
                    
                    // Ïû•Ïï†Î¨º ÏïûÏóêÏÑú ÏÜçÎèÑ Ïú†ÏßÄ (Í≤ΩÏ∞∞ÏùÄ ÌÑ±ÏùÑ ÏâΩÍ≤å ÎÑòÏùå)
                    const speedMultiplier = decision.nearObstacle ? 0.95 : 1.0;
                    
                    // ÏÜçÎèÑ Ï°∞Ï†à
                    if (this.speed < desiredSpeed * speedMultiplier) {
                        this.speed += this.acceleration;
                    } else {
                        this.speed -= this.acceleration * 0.3;
                    }
                    this.speed = Math.max(0, Math.min(this.maxSpeed, this.speed));
                    
                    // ÌöåÏ†Ñ
                    const currentAngle = Math.atan2(
                        this.body.velocity.z,
                        this.body.velocity.x
                    );
                    
                    let angleDiff = this.targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    const turnAmount = angleDiff * this.turnSpeed;
                    
                    // Ïù¥Îèô
                    const moveX = Math.cos(currentAngle + turnAmount) * this.speed;
                    const moveZ = Math.sin(currentAngle + turnAmount) * this.speed;
                    
                    this.body.velocity.x = moveX;
                    this.body.velocity.z = moveZ;
                    this.body.velocity.y = Math.max(this.body.velocity.y, -10);
                    
                    // Î©îÏãú ÏóÖÎç∞Ïù¥Ìä∏
                    this.mesh.position.copy(this.body.position);
                    this.mesh.quaternion.copy(this.body.quaternion);
                    
                    // Í±∑Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
                    if (this.speed > 0.5) {
                        this.walkCycle += this.speed * 0.2;
                        this.leftLeg.rotation.x = Math.sin(this.walkCycle) * 0.5;
                        this.rightLeg.rotation.x = -Math.sin(this.walkCycle) * 0.5;
                        this.leftArm.rotation.x = -Math.sin(this.walkCycle) * 0.3;
                        this.rightArm.rotation.x = Math.sin(this.walkCycle) * 0.3;
                    }
                    
                    // Ï≤¥Ìè¨ Ï≤¥ÌÅ¨
                    if (minDist < 1.5 && !nearestThief.caught && !nearestThief.escaped) {
                        nearestThief.caught = true;
                        addLog('üöî Í≤ΩÏ∞∞Ïù¥ ÎèÑÎëëÏùÑ Ï≤¥Ìè¨ÌñàÏäµÎãàÎã§!', 'cop');
                    }
                }
                
                remove() {
                    scene.remove(this.mesh);
                    world.removeBody(this.body);
                }
            }

            // ===== AI Ïª®Ìä∏Î°§Îü¨ =====
            class ThiefAI {
                constructor(generation) {
                    this.generation = generation;
                    this.strategy = gameState.thiefStrategies[
                        Math.min(generation - 1, gameState.thiefStrategies.length - 1)
                    ];
                }
                
                decide(position, obstacles, goal, nearestCop) {
                    const goalAngle = Math.atan2(
                        goal.z - position.z,
                        goal.x - position.x
                    );
                    
                    // Í∞ÄÍπåÏö¥ Ïû•Ïï†Î¨º Ï∞æÍ∏∞
                    let nearestObstacle = null;
                    let minObstacleDist = Infinity;
                    
                    obstacles.forEach(obs => {
                        const dx = obs.position.x - position.x;
                        const dz = obs.position.z - position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < minObstacleDist && dist < 5) {
                            minObstacleDist = dist;
                            nearestObstacle = obs;
                        }
                    });
                    
                    let targetAngle = goalAngle;
                    let speed = this.generation >= 3 ? 7 : 5;
                    
                    // ÏÑ∏ÎåÄÎ≥Ñ Ï†ÑÎûµ
                    if (nearestObstacle && minObstacleDist < 3) {
                        // ÌÑ± ÌöåÌîº (2ÏÑ∏ÎåÄ Ïù¥ÏÉÅ)
                        if (this.generation >= 2) {
                            const avoidAngle = Math.atan2(
                                nearestObstacle.position.z - position.z,
                                nearestObstacle.position.x - position.x
                            );
                            targetAngle = avoidAngle + Math.PI / 2;
                            speed = 4;  // Ïû•Ïï†Î¨º ÏïûÏóêÏÑú ÎäêÎ†§Ïßê
                        } else {
                            speed = 2;  // 1ÏÑ∏ÎåÄÎäî Îß§Ïö∞ ÎäêÎ†§Ïßê
                        }
                    }
                    
                    // Í≤ΩÏ∞∞Í≥ºÏùò Í±∞Î¶¨ Í≥†Î†§ (3ÏÑ∏ÎåÄ Ïù¥ÏÉÅ)
                    if (nearestCop && this.generation >= 3) {
                        const copDx = nearestCop.position.x - position.x;
                        const copDz = nearestCop.position.z - position.z;
                        const copDist = Math.sqrt(copDx * copDx + copDz * copDz);
                        
                        if (copDist < 5) {
                            const copAngle = Math.atan2(copDz, copDx);
                            // Í≤ΩÏ∞∞ Î∞òÎåÄ Î∞©Ìñ•ÏúºÎ°ú ÏÇ¥Ïßù ÌöåÌîº
                            targetAngle = goalAngle - (copAngle - goalAngle) * 0.3;
                        }
                    }
                    
                    return { targetAngle, speed };
                }
            }

            class CopAI {
                constructor(generation) {
                    this.generation = generation;
                    this.strategy = gameState.copStrategies[
                        Math.min(generation - 1, gameState.copStrategies.length - 1)
                    ];
                }
                
                decide(position, targetPos, obstacles, distance) {
                    const directAngle = Math.atan2(
                        targetPos.z - position.z,
                        targetPos.x - position.x
                    );
                    
                    let targetAngle = directAngle;
                    let speed = 5;
                    let nearObstacle = false;
                    
                    // Í∞ÄÍπåÏö¥ Ïû•Ïï†Î¨º Ï≤¥ÌÅ¨
                    obstacles.forEach(obs => {
                        const dx = obs.position.x - position.x;
                        const dz = obs.position.z - position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist < 2) {
                            nearObstacle = true;
                        }
                    });
                    
                    // ÏÑ∏ÎåÄÎ≥Ñ Ï†ÑÎûµ
                    if (this.generation >= 2 && distance > 10) {
                        // Î©ÄÎ¶¨ ÏûàÏùÑ ÎïåÎäî Ïä§ÌÉúÎØ∏ÎÇò ÏïÑÎÅºÍ∏∞
                        speed = 4;
                    } else if (this.generation >= 3 && distance < 8) {
                        // Í∞ÄÍπåÏö∞Î©¥ Ïä§ÌçºÌä∏
                        speed = 5.5;
                    }
                    
                    // ÏòàÏ∏° Ïù¥Îèô (4ÏÑ∏ÎåÄ Ïù¥ÏÉÅ)
                    if (this.generation >= 4 && distance < 15) {
                        // ÎèÑÎëëÏùò Ïù¥Îèô Î∞©Ìñ• ÏòàÏ∏°
                        targetAngle = directAngle + (Math.random() - 0.5) * 0.3;
                    }
                    
                    return { targetAngle, speed, nearObstacle };
                }
            }

            // ===== Ïû•Ïï†Î¨º ÏÉùÏÑ± =====
            function createObstacles() {
                const obstacles = [];
                
                // ÌÑ± (Í≥ÑÎã® Í∞ôÏùÄ ÎÜíÏù¥)
                for (let i = 0; i < 5; i++) {
                    const z = -10 - i * 15;
                    const curb = createCurb(-3, z);
                    obstacles.push(curb);
                }
                
                // Î≥ºÎùºÎìú
                for (let i = 0; i < 8; i++) {
                    const z = -5 - i * 12;
                    const x = (Math.random() - 0.5) * 8;
                    const bollard = createBollard(x, z);
                    obstacles.push(bollard);
                }
                
                // Í≤ΩÏÇ¨Î°ú (ÎèÑÏõÄ)
                for (let i = 0; i < 3; i++) {
                    const z = -15 - i * 20;
                    createRamp(5, z);
                }
                
                return obstacles;
            }

            function createCurb(x, z) {
                const geometry = new THREE.BoxGeometry(8, 0.3, 1);
                const mesh = new THREE.Mesh(geometry, sharedMaterials.obstacle);
                mesh.position.set(x, 0.15, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                
                const shape = new CANNON.Box(new CANNON.Vec3(4, 0.15, 0.5));
                const body = new CANNON.Body({ mass: 0 });
                body.addShape(shape);
                body.position.set(x, 0.15, z);
                world.addBody(body);
                
                return { mesh, body, position: { x, z } };
            }

            function createBollard(x, z) {
                const geometry = new THREE.CylinderGeometry(0.15, 0.2, 0.8, 8);
                const mesh = new THREE.Mesh(geometry, sharedMaterials.obstacle);
                mesh.position.set(x, 0.4, z);
                mesh.castShadow = true;
                scene.add(mesh);
                
                const shape = new CANNON.Cylinder(0.15, 0.2, 0.8, 8);
                const body = new CANNON.Body({ mass: 0 });
                body.addShape(shape);
                body.position.set(x, 0.4, z);
                world.addBody(body);
                
                return { mesh, body, position: { x, z } };
            }

            function createRamp(x, z) {
                const geometry = new THREE.BoxGeometry(3, 0.1, 5);
                const mesh = new THREE.Mesh(geometry, sharedMaterials.ramp);
                mesh.position.set(x, 0.05, z);
                mesh.rotation.x = -Math.PI / 12;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }

            // ===== Î™©Ìëú ÏßÄÏ†ê =====
            function createGoal() {
                const geometry = new THREE.PlaneGeometry(20, 3);
                const mesh = new THREE.Mesh(geometry, sharedMaterials.goal);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(0, 0.02, -95);
                scene.add(mesh);
                
                return { mesh, z: -95, x: 0 };
            }

            // ===== Í≤åÏûÑ Í∞ùÏ≤¥ =====
            let thieves = [];
            let cops = [];
            let obstacles = [];
            let goal = null;

            function initRound() {
                // Í∏∞Ï°¥ Í∞ùÏ≤¥ Ï†úÍ±∞
                thieves.forEach(t => t.remove());
                cops.forEach(c => c.remove());
                thieves = [];
                cops = [];
                
                // ÎèÑÎëë ÏÉùÏÑ± (3Î™Ö)
                for (let i = 0; i < 3; i++) {
                    const thief = new WheelchairThief(
                        (i - 1) * 3,
                        5,
                        new ThiefAI(gameState.thiefGeneration)
                    );
                    thieves.push(thief);
                }
                
                // Í≤ΩÏ∞∞ ÏÉùÏÑ± (3Î™Ö)
                for (let i = 0; i < 3; i++) {
                    const cop = new Cop(
                        (i - 1) * 3,
                        15,
                        new CopAI(gameState.copGeneration)
                    );
                    cops.push(cop);
                }
                
                gameState.startTime = Date.now();
                updateUI();
                addLog('üéÆ ÏÉàÎ°úÏö¥ ÎùºÏö¥Îìú ÏãúÏûë!', 'system');
            }

            // Ï¥àÍ∏∞ Îßµ ÏÉùÏÑ±
            obstacles = createObstacles();
            goal = createGoal();

            // ===== UI ÏóÖÎç∞Ïù¥Ìä∏ =====
            function updateUI() {
                document.getElementById('round-number').textContent = gameState.round;
                document.getElementById('thief-count').textContent = thieves.filter(t => !t.caught && !t.escaped).length;
                document.getElementById('cop-count').textContent = cops.length;
                
                document.getElementById('thief-generation').textContent = `${gameState.thiefGeneration}ÏÑ∏ÎåÄ`;
                document.getElementById('cop-generation').textContent = `${gameState.copGeneration}ÏÑ∏ÎåÄ`;
                
                const thiefWinRate = gameState.totalRounds > 0 
                    ? (gameState.thiefWins / gameState.totalRounds * 100).toFixed(0)
                    : 0;
                const copWinRate = gameState.totalRounds > 0
                    ? (gameState.copWins / gameState.totalRounds * 100).toFixed(0)
                    : 0;
                
                document.getElementById('thief-winrate').textContent = `${thiefWinRate}%`;
                document.getElementById('cop-winrate').textContent = `${copWinRate}%`;
                
                const thiefStrategyIndex = Math.min(gameState.thiefGeneration - 1, gameState.thiefStrategies.length - 1);
                const copStrategyIndex = Math.min(gameState.copGeneration - 1, gameState.copStrategies.length - 1);
                
                document.getElementById('thief-strategy').textContent = `Ï†ÑÎûµ: ${gameState.thiefStrategies[thiefStrategyIndex]}`;
                document.getElementById('cop-strategy').textContent = `Ï†ÑÎûµ: ${gameState.copStrategies[copStrategyIndex]}`;
            }

            function updateDistanceGauge() {
                if (thieves.length === 0 || cops.length === 0) return;
                
                // Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÎèÑÎëë-Í≤ΩÏ∞∞ Í±∞Î¶¨
                let minDist = Infinity;
                thieves.forEach(thief => {
                    if (thief.caught || thief.escaped) return;
                    cops.forEach(cop => {
                        const dx = thief.body.position.x - cop.body.position.x;
                        const dz = thief.body.position.z - cop.body.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        minDist = Math.min(minDist, dist);
                    });
                });
                
                const maxDist = 30;
                const percentage = Math.max(0, Math.min(100, (minDist / maxDist) * 100));
                
                document.getElementById('distance-fill').style.width = percentage + '%';
                document.getElementById('distance-text').textContent = `Í±∞Î¶¨: ${minDist.toFixed(1)}m`;
                
                if (minDist < 3) {
                    document.getElementById('distance-text').style.color = '#ff0000';
                } else if (minDist < 8) {
                    document.getElementById('distance-text').style.color = '#ffff00';
                } else {
                    document.getElementById('distance-text').style.color = '#00ff00';
                }
            }

            function addLog(message, type) {
                const logItems = document.getElementById('log-items');
                const item = document.createElement('div');
                item.className = `event-item event-${type}`;
                item.textContent = message;
                logItems.insertBefore(item, logItems.firstChild);
                
                // ÏµúÎåÄ 20Í∞úÎßå Ïú†ÏßÄ
                while (logItems.children.length > 20) {
                    logItems.removeChild(logItems.lastChild);
                }
            }

            function checkRoundEnd() {
                const escapedCount = thieves.filter(t => t.escaped).length;
                const caughtCount = thieves.filter(t => t.caught).length;
                
                if (escapedCount + caughtCount >= thieves.length) {
                    gameState.totalRounds++;
                    
                    if (escapedCount > caughtCount) {
                        gameState.thiefWins++;
                        addLog(`üèÜ ÎèÑÎëë ÌåÄ ÏäπÎ¶¨! (${escapedCount}Î™Ö ÌÉàÏ∂ú)`, 'thief');
                        
                        // ÎèÑÎëëÏù¥ Ïù¥Í∏∞Î©¥ Í≤ΩÏ∞∞ ÏÑ∏ÎåÄ Ï¶ùÍ∞Ä
                        if (gameState.totalRounds % 3 === 0) {
                            gameState.copGeneration++;
                            addLog(`üöî Í≤ΩÏ∞∞ AI ÏßÑÌôî: ${gameState.copGeneration}ÏÑ∏ÎåÄ`, 'cop');
                        }
                    } else {
                        gameState.copWins++;
                        addLog(`üèÜ Í≤ΩÏ∞∞ ÌåÄ ÏäπÎ¶¨! (${caughtCount}Î™Ö Ï≤¥Ìè¨)`, 'cop');
                        
                        // Í≤ΩÏ∞∞Ïù¥ Ïù¥Í∏∞Î©¥ ÎèÑÎëë ÏÑ∏ÎåÄ Ï¶ùÍ∞Ä
                        if (gameState.totalRounds % 3 === 0) {
                            gameState.thiefGeneration++;
                            addLog(`ü¶Ω ÎèÑÎëë AI ÏßÑÌôî: ${gameState.thiefGeneration}ÏÑ∏ÎåÄ`, 'thief');
                        }
                    }
                    
                    gameState.round++;
                    
                    setTimeout(() => {
                        initRound();
                    }, 2000);
                }
            }

            // ===== Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑ =====
            function animate() {
                requestAnimationFrame(animate);
                
                if (gameState.playing && !gameState.paused) {
                    const deltaTime = 1 / 60 * gameState.speed;
                    world.step(deltaTime);
                    
                    // Í≤ΩÍ≥º ÏãúÍ∞Ñ
                    gameState.elapsedTime = (Date.now() - gameState.startTime) / 1000;
                    const elapsedEl = document.getElementById('elapsed-time');
                    if (elapsedEl) {
                        elapsedEl.textContent = gameState.elapsedTime.toFixed(1) + 's';
                    }
                    
                    // ÎèÑÎëë ÏóÖÎç∞Ïù¥Ìä∏
                    thieves.forEach(thief => {
                        const nearestCop = cops.reduce((nearest, cop) => {
                            const dx = cop.body.position.x - thief.body.position.x;
                            const dz = cop.body.position.z - thief.body.position.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            
                            if (!nearest || dist < nearest.dist) {
                                return { cop, dist, position: cop.body.position };
                            }
                            return nearest;
                        }, null);
                        
                        thief.update(obstacles, goal, nearestCop ? nearestCop.position : null);
                    });
                    
                    // Í≤ΩÏ∞∞ ÏóÖÎç∞Ïù¥Ìä∏
                    cops.forEach(cop => {
                        cop.update(thieves, obstacles);
                    });
                    
                    updateDistanceGauge();
                    checkRoundEnd();
                }
                
                renderer.render(scene, camera);
            }

            // ===== Ïª®Ìä∏Î°§ =====
            document.getElementById('btn-start').addEventListener('click', () => {
                if (!gameState.playing) {
                    gameState.playing = true;
                    gameState.paused = false;
                    initRound();
                    addLog('Í≤åÏûÑ ÏãúÏûë!', 'system');
                } else {
                    gameState.paused = false;
                }
            });

            document.getElementById('btn-pause').addEventListener('click', () => {
                gameState.paused = !gameState.paused;
                addLog(gameState.paused ? 'ÏùºÏãúÏ†ïÏßÄ' : 'Ïû¨Í∞ú', 'system');
            });

            document.getElementById('btn-reset').addEventListener('click', () => {
                gameState.playing = false;
                gameState.round = 1;
                gameState.thiefGeneration = 1;
                gameState.copGeneration = 1;
                gameState.thiefWins = 0;
                gameState.copWins = 0;
                gameState.totalRounds = 0;
                
                thieves.forEach(t => t.remove());
                cops.forEach(c => c.remove());
                thieves = [];
                cops = [];
                
                updateUI();
                addLog('Í≤åÏûÑ Î¶¨ÏÖã', 'system');
            });

            document.getElementById('btn-speed').addEventListener('click', () => {
                const speeds = [1, 2, 4];
                const currentIndex = speeds.indexOf(gameState.speed);
                gameState.speed = speeds[(currentIndex + 1) % speeds.length];
                document.getElementById('btn-speed').textContent = `‚ö° ÏÜçÎèÑ: ${gameState.speed}x`;
                addLog(`Ïû¨ÏÉù ÏÜçÎèÑ: ${gameState.speed}x`, 'system');
            });

            // AI Î™®Îìú ÌÜ†Í∏Ä
            document.getElementById('btn-ai-mode').addEventListener('click', () => {
                const modes = ['thief-only', 'both', 'cop-only'];
                const currentIndex = modes.indexOf(gameState.aiMode);
                gameState.aiMode = modes[(currentIndex + 1) % modes.length];
                
                const btn = document.getElementById('btn-ai-mode');
                const desc = document.getElementById('ai-mode-desc');
                
                if (gameState.aiMode === 'thief-only') {
                    btn.textContent = 'ü¶Ω ÎèÑÎëëÎßå AI';
                    desc.textContent = 'Í≤ΩÏ∞∞: ÌîåÎ†àÏù¥Ïñ¥ Ï°∞Ïûë';
                    addLog('Î™®Îìú: ÎèÑÎëëÎßå AI (Í≤ΩÏ∞∞ÏùÄ ÌîåÎ†àÏù¥Ïñ¥)', 'system');
                } else if (gameState.aiMode === 'both') {
                    btn.textContent = 'ü§ñ Ï†ÑÎ∂Ä AI';
                    desc.textContent = 'ÎèÑÎëë & Í≤ΩÏ∞∞: AI';
                    addLog('Î™®Îìú: Ï†ÑÎ∂Ä AI (Í¥ÄÏ†Ñ Î™®Îìú)', 'system');
                } else {
                    btn.textContent = 'üöî Í≤ΩÏ∞∞Îßå AI';
                    desc.textContent = 'ÎèÑÎëë: ÌîåÎ†àÏù¥Ïñ¥ Ï°∞Ïûë';
                    addLog('Î™®Îìú: Í≤ΩÏ∞∞Îßå AI (ÎèÑÎëëÏùÄ ÌîåÎ†àÏù¥Ïñ¥)', 'system');
                }
            });

            // Î™®Î∞îÏùº Î©îÎâ¥
            document.getElementById('menu-toggle').addEventListener('click', () => {
                const menu = document.getElementById('mobile-menu');
                menu.classList.toggle('active');
            });

            // Ï∞Ω ÌÅ¨Í∏∞ Ï°∞Ï†à
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
            animate();
            updateUI();
            
            console.log('‚úÖ Í≤åÏûÑ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å!');
        }

        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Í≤åÏûÑ Ï¥àÍ∏∞Ìôî
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initGame);
        } else {
            initGame();
        }
    </script>
</body>
</html>
